// SPDX-License-Identifier: MIT
// apps/backend/src/routes/functionsCatalog/functionsCatalog.ts

import { Router, Request, Response } from 'express';
import {
  FunctionsCatalogService,
  type MenuContext,
} from '../../services/functionsCatalogService.js';
import db from '../../services/dbService.js';

const router = Router();
const service = new FunctionsCatalogService();

/* -----------------------------------------------------------
   Hilfsfunktion für konsistentes Fehler-Handling
----------------------------------------------------------- */
function sendError(res: Response, source: string, error: unknown, status = 500) {
  const message = error instanceof Error ? error.message : String(error);
  console.error(`[functionsCatalogRouter] ${source} error:`, message);
  res.status(status).json({ success: false, error: message });
}

/* -----------------------------------------------------------
   Regeln anzeigen
----------------------------------------------------------- */
router.get('/rules', async (_req: Request, res: Response) => {
  try {
    const rules = service.getRuleSnapshot();
    res.json({ success: true, rules });
  } catch (e) {
    sendError(res, 'rules', e);
  }
});

/* -----------------------------------------------------------
   Index neu aufbauen (Cache refresh)
----------------------------------------------------------- */
router.post('/reload', async (_req: Request, res: Response) => {
  try {
    const result = await service.refreshFunctionsIndex();
    res.json({
      success: true,
      loadedAt: result.loadedAt,
      findings: result.findings,
      warnings: result.warnings ?? [],
    });
  } catch (e) {
    sendError(res, 'reload', e);
  }
});

/* -----------------------------------------------------------
   Voller Funktions-Index (optional: strict, kinds, flat)
----------------------------------------------------------- */
router.get('/index', async (req: Request, res: Response) => {
  try {
    const strict = req.query.strict === '1';
    const kinds =
      typeof req.query.kinds === 'string'
        ? (req.query.kinds as string)
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
        : undefined;
    const flat = req.query.flat === '1';

    const result = strict
      ? await new FunctionsCatalogService({ strict: true }).buildCatalog()
      : await service.getFunctionsIndex();

    let nodes = result.nodes ?? [];

    // Filterung nach "kinds"
    if (kinds?.length) {
      type NodeLike = { kind: string; children?: NodeLike[] };
      const list: NodeLike[] = [];

      const visit = (n: NodeLike) => {
        if (kinds.includes(n.kind)) list.push(n);
        n.children?.forEach(visit);
      };
      nodes.forEach(visit);

      if (flat) {
        return res.json({
          success: true,
          nodes: list,
          loadedAt: result.loadedAt,
        });
      } else {
        const grouped: Record<string, NodeLike[]> = {};
        for (const n of list) {
          (grouped[n.kind] = grouped[n.kind] || []).push(n);
        }
        return res.json({
          success: true,
          nodesGrouped: grouped,
          loadedAt: result.loadedAt,
        });
      }
    }

    res.json({
      success: true,
      nodes,
      loadedAt: result.loadedAt,
      findings: result.findings ?? [],
      warnings: result.warnings ?? [],
    });
  } catch (e) {
    sendError(res, 'index', e);
  }
});

/* -----------------------------------------------------------
   Menü nach Rollen / Features
----------------------------------------------------------- */
router.post('/menu', async (req: Request, res: Response) => {
  try {
    const ctx: MenuContext = {
      roles: Array.isArray(req.body?.roles) ? req.body.roles : undefined,
      features: Array.isArray(req.body?.features)
        ? req.body.features
        : undefined,
    };
    const { menu, loadedAt } = await service.getMenuForContext(ctx);
    res.json({ success: true, menu, loadedAt });
  } catch (e) {
    sendError(res, 'menu', e);
  }
});

/* -----------------------------------------------------------
   Liste der Quelldateien
----------------------------------------------------------- */
router.get('/files', (_req: Request, res: Response) => {
  try {
    const files = service.getSourceFiles();
    res.json({ success: true, files });
  } catch (e) {
    sendError(res, 'files', e);
  }
});

/* -----------------------------------------------------------
   Lint-Findings
----------------------------------------------------------- */
router.get('/lint', async (_req: Request, res: Response) => {
  try {
    const { findings, loadedAt } = await service.lintFunctions();
    res.json({ success: true, findings, loadedAt });
  } catch (e) {
    sendError(res, 'lint', e);
  }
});

/* -----------------------------------------------------------
   Einzelknoten + Breadcrumbs + UI-Hinweise
----------------------------------------------------------- */
router.get('/nodes/:id', async (req: Request, res: Response) => {
  try {
    const node = await service.getNodeById(req.params.id);
    if (!node) return res.status(404).json({ success: false, error: 'NOT_FOUND' });
    res.json({ success: true, node });
  } catch (e) {
    sendError(res, 'nodes/:id', e);
  }
});

/* -----------------------------------------------------------
   direkte Kinder eines Knotens
----------------------------------------------------------- */
router.get('/nodes/:id/children', async (req: Request, res: Response) => {
  try {
    const id = req.params.id;
    const roles =
      typeof req.query.roles === 'string'
        ? (req.query.roles as string)
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
        : undefined;
    const features =
      typeof req.query.features === 'string'
        ? (req.query.features as string)
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
        : undefined;

    const out = await service.getChildrenForNode(id, { roles, features });
    if (!out) return res.status(404).json({ success: false, error: 'NOT_FOUND' });
    res.json({ success: true, ...out });
  } catch (e) {
    sendError(res, 'nodes/:id/children', e);
  }
});

/* -----------------------------------------------------------
   Volltext-Suche
----------------------------------------------------------- */
router.get('/search', async (req: Request, res: Response) => {
  try {
    const q = String(req.query.q || '').trim();
    const kinds =
      typeof req.query.kinds === 'string'
        ? (req.query.kinds as string)
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
        : undefined;
    const tags =
      typeof req.query.tags === 'string'
        ? (req.query.tags as string)
            .split(',')
            .map((s) => s.trim().toLowerCase())
            .filter(Boolean)
        : undefined;

    const results = await service.search({ q, kinds, tags });
    res.json({ success: true, results });
  } catch (e) {
    sendError(res, 'search', e);
  }
});

/* -----------------------------------------------------------
   Katalog → DB persistieren (Basis-Schema)
----------------------------------------------------------- */
router.post('/persist', async (_req: Request, res: Response) => {
  try {
    const result = await service.getFunctionsIndex();
    const summary = await db.upsertFunctionsCatalog(result);
    res.json({ success: true, ...summary });
  } catch (e) {
    sendError(res, 'persist', e);
  }
});
/* -----------------------------------------------------------
   Root-Endpunkt (/api/functions)
   → liefert eine kompakte Zusammenfassung des Katalogzustands
----------------------------------------------------------- */
router.get('/', async (_req, res) => {
  try {
    const summary = await service.getFunctionsSummary();

    // Hole zusätzlich die echten Nodes (für Dashboard-Kompatibilität)
    const index = await service.getFunctionsIndex();

    res.json({
      success: true,
      data: {
        loadedAt: summary.loadedAt,
        nodes: index.nodes,             // <-- hier: Array
        categories: summary.categories,
        warnings: summary.warnings,
        findings: summary.findings,
      },
    });
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    console.error('[functionsCatalogRouter] Fehler beim Root-Endpoint:', msg);
    res.status(500).json({ success: false, error: msg });
  }
});



export default router;
