// SPDX-License-Identifier: MIT
// apps/backend/src/services/aiAnnotatorService.ts

import db from "./dbService.js";
import { EventEmitter } from "events";

const DEFAULT_AI_PROVIDER = "ollama";
const DEFAULT_AI_MODEL = process.env.OLLAMA_MODEL || "qwen2:7b";

// ============ ERWEITERTE TYP-DEFINITIONEN ============

export type GeneratedMeta = {
  description: string;
  tags: string[];

  businessArea?: string;

  piiClass?: "none" | "low" | "medium" | "high";

  requires?: string[];

  quality?: { 
    confidence: number; 
    evidence?: string[];
    generatedBy: "ai";
    modelUsed?: string;

    // Ergänzend (nicht verpflichtend, rein kompatibel):
    reasoning?: string;             // kurze Begründung der Meta-Entscheidungen
    aiTimestamp?: string;           // Zeitstempel der KI-Erzeugung
  };

  technical?: {
    complexity: "low" | "medium" | "high";
    dataVolume: "small" | "medium" | "large";
    integrationPoints: string[];
    performanceImpact: "low" | "medium" | "high";

    // Ergänzend:
    estimatedDbLoad?: "low" | "medium" | "high";
    externalInterfaces?: string[];      // z.B. ["CRM", "Warenwirtschaft"]
    transactionPatterns?: string[];     // z.B. ["read-heavy", "write-heavy"]
    concurrencyRisk?: "low" | "medium" | "high";
  };

  compliance?: {
    gdprRelevant: boolean;
    retentionPeriod?: number;
    auditRequired: boolean;

    // Ergänzend:
    legalReferences?: string[];         // z.B. ["DSGVO Art. 6", "GoBD §147"]
    riskLevel?: "low" | "medium" | "high";
  };

  // Ergänzend – optional, bricht nichts:
  domainHints?: string[];               // ERP-Kontextschlüsselwörter aus KI-Analyse
  recommendedKPIs?: string[];           // z.B. für Dashboards geeignete Metriken
  notes?: string;                       // generische KI-Notizen
};


export type DashboardRule = {
  type:
    | "dashboard-root"
    | "section"
    | "metric"
    | "report"
    | "form"
    | "table"
    | "action"
    | "config"
    | "chart"
    | "kpi"
    | "alerts";

  widget?:
    | "number"
    | "chart"
    | "gauge"
    | "table"
    | "form"
    | "button"
    | "tabs"
    | "grid"
    | "panel"
    | "progress"
    | "timeline"
    | "map";

  dataSource?: string;
  refreshInterval?: number;
  unit?: string;
  permissions?: string[];

  layout?: {
    colSpan?: number;
    rowSpan?: number;
    priority?: number;
    responsive?: boolean;

    /** z. B. mobile, tablet, desktop */
    breakpoints?: Record<string, any>;

    /** Ergänzend – für detaillierte ERP-Dashboards */
    minWidth?: number;
    minHeight?: number;
    maxWidth?: number;
    maxHeight?: number;
  };

  aggregation?: string;
  timeRange?: string;
  colorScheme?: string;

  thresholds?: {
    warning: number;
    critical: number;
    success: number;
  };

  alerts?: AlertRule[];

  /** Ergänzend: zusätzliche ERP-Dashboard-spezifische Informationen */
  kpiDefinition?: {
    formula?: string;
    sourceFields?: string[];
    interpretation?: string;   // z.B. „höher = besser“
  };

  interactions?: {
    onClick?: string;
    drillDown?: string[];
    navigationTarget?: string;
  };

  metadata?: {
    createdAt?: string;
    createdBy?: string;
    tags?: string[];
  };
};


export type AlertRule = {
  condition: string;
  severity: "info" | "warning" | "error" | "critical";
  message: string;
  actions: string[];

  /** Ergänzend */
  cooldown?: number; // Sekunden bis erneute Auslösung erlaubt
  active?: boolean;
  notifyChannels?: ("email" | "sms" | "webhook" | "ui")[];
};


export type FormSpec = {
  title: string;
  description?: string;

  fields: FormField[];

  layout: "vertical" | "horizontal" | "wizard" | "tabs" | "accordion";

  validation?: ValidationRule[];

  actions: string[];

  sections?: FormSection[];

  conditionalLogic?: ConditionalLogic[];

  /** Ergänzend – ERP-Formulare brauchen oft Workflow-Meta */
  workflow?: {
    beforeSubmit?: string[];
    afterSubmit?: string[];
    autoSave?: boolean;
  };

  /** Layout-Optimierung */
  uiHints?: {
    dense?: boolean;
    showSteps?: boolean;
    showDivider?: boolean;
    collapsible?: boolean;
  };

  /** Hilfreich für späteres UI-Rendering */
  metadata?: {
    createdAt?: string;
    createdBy?: string;
    tags?: string[];
  };
};


export type FormSection = {
  title: string;
  description?: string;

  /** Feldnamen, die in dieser Sektion angezeigt werden sollen */
  fields: string[];

  /** Einfache Sichtbarkeitslogik */
  conditional?: {
    field: string;
    operator?: "equals" | "notEquals" | "contains" | "greaterThan" | "lessThan";
    value: any;
  };

  /** Neue optionale Hinweise für UI/ERP-Kontexte */
  collapsed?: boolean;         // initial eingeklappt
  collapsible?: boolean;       // Benutzer darf die Sektion ein-/ausklappen
  highlight?: boolean;         // visuell hervorheben
  order?: number;              // explizite Sortier-Reihenfolge

  /** Erweiterung für komplexere Layouts */
  layout?: {
    columns?: number;          // z. B. 1,2,3 Spalten
    columnSpan?: number;       // z. B. für große Eingabefelder
    padding?: number;
    gap?: number;
  };

  /** Metadaten zur besseren Nachvollziehbarkeit */
  metadata?: {
    createdAt?: string;
    createdBy?: string;
    tags?: string[];
  };
};


export type FormField = {
  name: string;
  type:
    | "text"
    | "number"
    | "date"
    | "select"
    | "checkbox"
    | "textarea"
    | "email"
    | "phone"
    | "currency"
    | "percentage"
    | "file"
    | "password";

  label: string;
  required?: boolean;
  options?: string[];
  placeholder?: string;
  validation?: FieldValidation;
  helpText?: string;
  defaultValue?: any;

  /** Sichtbarkeits-/Aktivierungslogik */
  conditional?: ConditionalLogic;

  /** Ergänzungen — kompatibel & sicher optional */
  readOnly?: boolean;                // UI: Feld kann angezeigt werden, aber nicht bearbeitet
  disabled?: boolean;                // direkt deaktiviert (unabhängig von conditional)
  hidden?: boolean;                  // im UI vollständig versteckt
  autoFocus?: boolean;               // beim Öffnen fokussieren
  width?: string | number;           // z. B. "50%", "300px"
  maxLength?: number;                // häufig für Textfelder
  minLength?: number;                // ebenfalls häufig
  tooltip?: string;                  // kurze UI-Erläuterung
  icon?: string;                     // UI-Symbol, oft genutzt in ERP-Formularen
  group?: string;                    // Gruppierung innerhalb einer Section (z. B. Adressdaten)
  unit?: string;                     // z. B. €, %, kg – wichtig für ERP-Daten
  dependsOn?: string[];              // einfache Abhängigkeiten ohne Logik
  dataSource?: string;               // externe Quelle für Select-Felder
  multiSelect?: boolean;             // erlaubt Mehrfachauswahl bei select
  sortable?: boolean;                // UI-Steuerung bei Feldlisten
  mask?: string;                     // Input-Masken (z. B. Telefonnummern)
  format?: string;                   // z. B. Datumsformat "YYYY-MM-DD"
};


export type ConditionalLogic = {
  /** Feld, auf dessen Wert geprüft wird */
  field: string;

  /** Vergleichsoperatoren */
  operator:
    | "equals"
    | "notEquals"
    | "contains"
    | "notContains"
    | "startsWith"
    | "endsWith"
    | "greaterThan"
    | "lessThan"
    | "greaterOrEqual"
    | "lessOrEqual"
    | "in"
    | "notIn";

  /** Vergleichswert */
  value: any;

  /** Reaktion des UI */
  action:
    | "show"
    | "hide"
    | "enable"
    | "disable"
    | "require"
    | "optional"
    | "setValue"
    | "clearValue";

  /** (Optional) Wert, der gesetzt werden soll – nur relevant bei setValue */
  setValue?: any;

  /** 
   * Optional: mehrere Bedingungen gleichzeitig verknüpfen  
   * z. B.: alle müssen wahr sein (AND) oder eine reicht (OR)
   */
  logic?: "AND" | "OR";

  /**
   * Optional: Verschachtelte Bedingungen für komplexe Formulare  
   * z. B. wenn mehrere Regeln gleichzeitig gelten sollen
   */
  conditions?: ConditionalLogic[];
};


export type ValidationRule = {
  /** Name des zu prüfenden Feldes */
  field: string;

  /** Art der Validierung */
  type:
    | "required"
    | "min"
    | "max"
    | "minLength"
    | "maxLength"
    | "pattern"
    | "custom"
    | "email"
    | "url"
    | "phone"
    | "dateBefore"
    | "dateAfter"
    | "unique"
    | "number";

  /** Wert für numerische, datumsbezogene oder musterbasierte Prüfungen */
  value?: any;

  /** Benutzerfreundliche Fehlermeldung */
  message: string;

  /** Optional: Custom-Validator-Name (z. B. serverseitige Prüfregeln) */
  validatorFn?: string;

  /** Optional: nur gültig unter bestimmten Bedingungen */
  conditional?: ConditionalLogic;
};


export type FieldValidation = {
  /** Numerische Mindestgrenze */
  min?: number;

  /** Numerische Höchstgrenze */
  max?: number;

  /** Regulärer Ausdruck für Musterprüfungen */
  pattern?: string;

  /** Name einer benutzerdefinierten Validierungsfunktion */
  custom?: string;

  /** Mindestlänge (für Textfelder) */
  minLength?: number;

  /** Maximale Länge (für Textfelder) */
  maxLength?: number;

  /** Liste erlaubter Werte (z. B. Statusfelder) */
  allowedValues?: any[];

  /** Datumsvalidierungen – z. B. muss Datum in der Zukunft liegen */
  dateAfterField?: string;
  dateBeforeField?: string;

  /** Erzwingt eindeutige Werte innerhalb eines Formulars oder Datensatzes */
  unique?: boolean;

  /** Pflichtfeldprüfung (optional, da auch ValidationRule dies abbildet) */
  required?: boolean;
};


export type NodeForAnnotation = {
  /** Technische ID des Knotens */
  id: string;

  /** Titel oder Funktionsname (muss nicht eindeutig sein) */
  title: string;

  /** Funktionsart, z. B. "function", "table", "workflow" */
  kind: string;

  /** Vollständiger Funktionspfad als Struktur, z. B. ["Finanzen", "Buchhaltung", "Rechnung"] */
  path: string[];

  /** Generierte oder manuell gepflegte Metadaten */
  meta_json?: any | null;

  /** Optionales Schema (z. B. Datenfelder, Strukturen) */
  schema_json?: any | null;

  /** Automatisierungs-/Workflow-Daten */
  aa_json?: any | null;

  /** Ursprungsdatei im Repository */
  source_file?: string | null;

  /** Dashboard-Regel, falls generiert */
  rule?: DashboardRule;

  /** Timestamps */
  created_at?: string;
  updated_at?: string;
  last_annotated?: string;

  /** Status des Annotationsprozesses */
  annotation_status?: 
    | "pending"
    | "processing"
    | "completed"
    | "failed"
    | "needs_review";

  /** Neue Zusatzfelder */

  /** Zeitstempel der letzten KI-Bearbeitung */
  ai_last_processed?: string | null;

  /** Anzahl der bisherigen KI-Versuche (nützlich bei Batches / Error Handling) */
  ai_attempts?: number | null;

  /** Genutztes Modell für die letzte Annotation */
  ai_model_used?: string | null;

  /** Interne Priorität (z. B. wichtig → zuerst annotieren) */
  priority?: number | null;

  /** Flags, ob manuell durch Entwickler bestätigt oder angepasst */
  manual_reviewed?: boolean;
  manual_locked?: boolean;

  /** Hash des aktuellen Inhalts zur Änderungserkennung */
  content_hash?: string | null;

  /** Optionale Kategorie oder Klassifikation */
  category?: string | null;

  /** Dynamische Zusatzattribute */
  attributes?: Record<string, any> | null;
};


export type BatchOperation = {
  /** Interne ID des Batch-Laufs */
  id?: string;

  /** Auszuführende Operation */
  operation:
    | "generate_meta"
    | "generate_forms"
    | "enhance_schema"
    | "classify_pii"
    | "generate_rule"
    | "full_annotation"
    | "validate_nodes";

  /** Filter für die Node-Auswahl */
  filters: any;

  /** Optionen für Ablaufsteuerung, Validierung, Parallelisierung usw. */
  options?: BatchOptions;

  /** Aktueller Status */
  status?: "pending" | "running" | "completed" | "failed" | "cancelled";

  /** Prozentualer Fortschritt */
  progress?: number;

  /** Timestamps */
  created_at?: string;
  started_at?: string;
  completed_at?: string;

  /** --- Neue sinnvolle optionale Felder --- */

  /** Ob dieser Batch manuell ausgelöst wurde oder automatisch */
  triggered_by?: "system" | "user" | "schedule";

  /** Benutzer oder Prozess, der den Batch ausgelöst hat */
  initiated_by?: string | null;

  /** Anzahl der Nodes, die theoretisch verarbeitet werden sollten (Snapshot vor Start) */
  expected_total?: number;

  /** Hash der Filter → für Wiederholungen / Caching */
  filter_hash?: string | null;

  /** Modell, das für diesen Batch bevorzugt verwendet wurde */
  model_used?: string | null;

  /** Batch-Priorität zur Reihung in der Warteschlange */
  priority?: number | null;

  /** Anzahl der bereits erfolgten Resumes/Restarts */
  restart_count?: number | null;

  /** Fehlerursache, falls der Batch vollständig fehlschlägt */
  failure_reason?: string | null;

  /** Metadaten des Systems zum Startzeitpunkt (Snapshot) */
  system_context?: Record<string, any> | null;
};


export type BatchOptions = {
  /** Erneut versuchen, wenn ein Node fehlschlägt */
  retryFailed?: boolean;

  /** Maximale Anzahl von KI-Retries pro Node */
  maxRetries?: number;

  /** Anzahl von Nodes pro Chunk */
  chunkSize?: number;

  /** Parallele Requests an die KI */
  parallelRequests?: number;

  /** Steuerung der Modellwahl */
  modelPreference?: "auto" | "fast" | "accurate" | "balanced";

  /** Validierungsregeln (Meta- oder Schemaqualität) */
  validationRules?: ValidationConfig;

  /** --- Ergänzungen: sicher, optional, sinnvoll --- */

  /** Timeout pro KI-Request in Millisekunden */
  requestTimeoutMs?: number;

  /** Warten zwischen den KI-Aufrufen zur Laststeuerung */
  throttleMs?: number;

  /** Abbruch des gesamten Batches, wenn X % Fehler überschritten werden */
  failOnErrorRate?: number;

  /** Max. Zeit in ms, bevor der Batch automatisch abgebrochen wird */
  maxRuntimeMs?: number;

  /** Spezielles Fallback-Verhalten für Modelle */
  fallbackStrategy?: "sequential" | "aggressive" | "disabled";

  /** Simulation-Modus: nur Prüfung, kein Speichern */
  dryRun?: boolean;

  /** Logging-Level für diesen Batch */
  logLevel?: "silent" | "error" | "warn" | "info" | "debug";

  /** Anzahl der Nodes, die *maximal* verarbeitet werden sollen (Soft-Limit) */
  limitNodes?: number;

  /** Fortschrittsspeicherung noch häufiger als Standard */
  progressUpdateInterval?: number;

  /** Spezielle Vorgaben für PII- oder Compliance-Operationen */
  complianceMode?: "strict" | "normal" | "minimal";

  /** Bei "full_annotation": Reihenfolge steuern */
  annotationOrder?: Array<"meta" | "rule" | "form">;

  /** Möglichkeit, alternative Modellgruppen zu erzwingen */
  allowedModels?: string[];
};

export type ValidationConfig = {
  /** Minimale Länge der Beschreibung */
  minDescriptionLength?: number;

  /** Maximale Anzahl erlaubter Tags */
  maxTags?: number;

  /** Felder, die zwingend in meta_json oder form_json vorhanden sein müssen */
  requiredFields?: string[];

  /** Nur diese Fachbereiche sind gültig */
  businessAreaWhitelist?: string[];

  /** --- Ergänzungen (optional, sicher, realistisch) --- */

  /** Prüfen, ob die PII-Klassifikation erlaubt ist */
  allowedPiiLevels?: Array<"none" | "low" | "medium" | "high">;

  /** Maximale Anzahl von Integration Points (techn. Metadaten) */
  maxIntegrationPoints?: number;

  /** Erlaubte Werte für meta.technical.complexity */
  allowedComplexityLevels?: Array<"low" | "medium" | "high">;

  /** Prüfung, ob compliant: z.B. retentionPeriod gesetzt sein muss */
  requireComplianceFields?: string[];

  /** Validierung für Dashboard-Regeln */
  ruleConstraints?: {
    allowedWidgets?: string[];
    allowedTypes?: string[];
    maxRefreshInterval?: number;
  };

  /** Validierungsregeln für Formulare */
  formConstraints?: {
    requireDescriptions?: boolean;
    requireHelpText?: boolean;
    maxFieldsPerForm?: number;
    maxSections?: number;
  };

  /** Flag: KI-Antwort muss strikt JSON sein */
  strictJson?: boolean;

  /** Warnen, wenn Confidence-Wert unterhalb dieser Schwelle liegt */
  minConfidenceThreshold?: number;

  /** Validierung aktiver Felder in Schemas */
  schemaConstraints?: {
    requireType?: boolean;
    allowedFieldTypes?: string[];
  };
};


export type BatchResult = {
  id: string;
  total: number;
  processed: number;
  successful: number;
  failed: number;
  errors: string[];

  results: Array<{
    id: string;
    success: boolean;
    result?: any;
    error?: string;
    retries?: number;
    duration?: number;

    /** Erweiterungen */
    startedAt?: string;
    finishedAt?: string;
    modelUsed?: string;
    warnings?: string[];
  }>;

  summary?: {
    averageConfidence: number;
    businessAreas: Record<string, number>;
    piiDistribution: Record<string, number>;
    qualityScore: number;

    /** Erweiterungen */
    averageDuration?: number;
    medianDuration?: number;
    retryStats?: {
      totalRetries: number;
      avgRetries: number;
      maxRetries: number;
    };
    modelUsage?: Record<string, number>;
    errorCategories?: Record<string, number>;
    warningCount?: number;
  };

  /** Zusätzliche Metadaten zum Batchvorgang selbst */
  started_at?: string;
  completed_at?: string;
  cancelled_at?: string;

  duration_ms?: number;
  modelUsed?: string;
  statusMessage?: string;
};


export type AIProvider =
  | "ollama"       // aktueller Provider
  | "openai"       // optional für spätere Nutzung
  | "anthropic"    // optional
  | "local"        // interner CPU/ONNX Interpreter
  | "none";        // fallback / deaktiviert


export type ModelConfig = {
  name: string;                        // Modellbezeichnung z. B. "qwen3:8b"
  provider: AIProvider;                // "ollama" | "none" | optional weitere Provider
  capabilities: string[];              // z. B. ["meta", "rule", "form", "complex"]
  maxTokens: number;                   // KI-Ausgabelimit
  contextWindow: number;               // Prompt-Kontextfenster
  speed: "slow" | "medium" | "fast";   // interne Einordnung
  accuracy: "low" | "medium" | "high"; // interne Einordnung
  available: boolean;                  // vom Health-Check gesetzt

  // ------- Ergänzungen (voll kompatibel, optional) -------
  version?: string;                    // erkennt z. B. "3.2", "1.5", "0.9"
  local?: boolean;                     // true = rein lokal (z. B. bei Ollama)
  tags?: string[];                     // zusätzliche Modellklassifikation
  description?: string;                // kurze interne Modellinfo
  lastChecked?: string;                // Health-Check Timestamp
};


export type ErrorCorrectionConfig = {
  enabled: boolean;            // Aktiviert/Deaktiviert Fehlerkorrektur
  maxRetries: number;          // Anzahl Wiederholungsversuche
  retryDelay: number;          // Verzögerung in ms zwischen Retries
  fallbackModels: string[];    // Reihenfolge der Fallback-Modelle
  validationRules: string[];   // Validierungsregeln, die berücksichtigt werden
  autoCorrect: boolean;        // Automatische Korrektur aktiv?

  // ----- Ergänzungen (nicht-required, bruchsicher) -----

  /**
   * Aktiviert Protokollierung/Debug-Ausgaben
   * – nützlich, da dein Terminal viele KI-Durchläufe loggt.
   */
  verbose?: boolean;

  /**
   * Wenn gesetzt: KI-Korrektur erhält systematische Zusatzhinweise,
   * z. B. "streng", "locker", "neutral"
   */
  correctionMode?: "strict" | "balanced" | "lenient";

  /**
   * Maximale Zeit pro Korrekturlauf (ms).
   * Verhindert Endlosschleifen, falls Modelle hängen.
   */
  maxDurationPerAttempt?: number;

  /**
   * Optional: KI bekommt eine zusammengefasste Fehlerliste
   * aus früheren Versuchen übergeben (Trend-Analyse).
   */
  provideErrorContext?: boolean;

  /**
   * Steuert, ob Fallback Modelle in Mischlogik genutzt werden,
   * z. B. nach Geschwindigkeit statt nur Reihenfolge.
   */
  fallbackStrategy?: "sequential" | "performance" | "accuracy";

  /**
   * Bricht sofort ab, sobald die KI mehrfach denselben Fehler produziert.
   */
  abortOnRepetition?: boolean;
};

export type GeneratedRule = {
  id: string;

  /**
   * Die generierte Dashboard-Regel (strukturierte KI-Ausgabe)
   */
  rule: DashboardRule;

  /**
   * Qualitäts- und Herkunftsmetriken der KI-Ausgabe
   */
  quality: {
    confidence: number;              // KI-Sicherheitswert
    evidence: string[];              // Begründungen / Hinweise
    generatedBy: "ai";               // Herkunftsflag
    modelUsed?: string;              // Optional: Modellname
    timestamp?: string;              // Optional: Zeit der Erzeugung
    version?: string;                // Optional: Schema/Format-Version
  };

  /**
   * — OPTIONALE FELDER —
   * Bruchsicher & nützlich für spätere Validierung
   */

  /**
   * Rohantwort des Modells (zur Fehleranalyse)
   */
  rawResponse?: string;

  /**
   * Warnungen, die bei der Erzeugung erkannt wurden
   */
  warnings?: string[];

  /**
   * Automatische Validierung (z. B. Layout-Checks)
   */
  validation?: {
    valid: boolean;
    issues?: string[];
  };

  /**
   * Node-Bezug (z. B. Titel), hilfreich beim Batch Processing
   */
  nodeRef?: {
    title?: string;
    path?: string[];
    kind?: string;
  };
};


export type GeneratedFormSpec = {
  id: string;

  /**
   * Das durch KI erzeugte Formular
   */
  form: FormSpec;

  /**
   * Qualitätsmetadaten der KI-Ausgabe
   */
  quality: {
    confidence: number;
    evidence: string[];
    generatedBy: "ai";
    modelUsed?: string;
    timestamp?: string;     // Optional: Zeitpunkt der Generierung
    version?: string;       // Optional: Format- oder Schema-Version
  };

  /**
   * — OPTIONALE ERWEITERUNGEN —
   */

  /**
   * Rohantwort der KI, zur späteren Analyse
   */
  rawResponse?: string;

  /**
   * Warnungen, die bei der Generierung auftraten (z. B. fehlende Felder)
   */
  warnings?: string[];

  /**
   * Automatische Validierung des FormSpecs
   */
  validation?: {
    valid: boolean;
    issues?: string[];
  };

  /**
   * Referenz auf den zugehörigen Node (zur Batch-Nachvollziehbarkeit)
   */
  nodeRef?: {
    title?: string;
    path?: string[];
    kind?: string;
  };
};


export type PiiResult = {
  /**
   * Eindeutige ID des analysierten Knotens
   */
  id: string;

  /**
   * Klassifikation der personenbezogenen Daten
   */
  piiClass: "none" | "low" | "medium" | "high";

  /**
   * Begründung aus der Analyse
   */
  reason: string;

  /**
   * Sicherheit der Klassifikation (0–1)
   */
  confidence: number;

  /**
   * Kennzeichnung, dass die Klassifikation durch KI erzeugt wurde
   */
  generatedBy: "ai";

  /**
   * OPTIONAL — verwendetes Modell
   */
  modelUsed?: string;

  /**
   * OPTIONAL — Zeitpunkt der Klassifikation
   */
  timestamp?: string;

  /**
   * OPTIONAL — Liste erkannter begründender Begriffe
   * (z. B. ["email", "adresse", "personalnummer"])
   */
  evidence?: string[];

  /**
   * OPTIONAL — Klassifikation der Datenart
   * z. B. „stammdaten“, „kommunikationsdaten“, „abrechnung“
   */
  dataCategory?: string;

  /**
   * OPTIONAL — Empfehlungen für Folgeaktionen (z. B. Maskierung)
   */
  recommendations?: string[];
};


// ============ DATABASE TOOL ============

export class DatabaseTool {
  private static instance: DatabaseTool;

  static getInstance(): DatabaseTool {
    if (!DatabaseTool.instance) {
      DatabaseTool.instance = new DatabaseTool();
    }
    return DatabaseTool.instance;
  }

  async getNodeStatistics(): Promise<{
    total: number;
    byKind: Record<string, number>;
    byStatus: Record<string, number>;
    annotationProgress: number;
    averageConfidence: number;
  }> {
    try {
      const nodes = await db.all<any>(`
        SELECT kind, annotation_status, meta_json
        FROM functions_nodes
        WHERE meta_json IS NOT NULL
      `);

      const stats = {
        total: nodes.length,
        byKind: {} as Record<string, number>,
        byStatus: {} as Record<string, number>,
        annotationProgress: 0,
        averageConfidence: 0
      };

      let totalConfidence = 0;
      let nodesWithConfidence = 0;

      for (const node of nodes) {
        stats.byKind[node.kind] = (stats.byKind[node.kind] || 0) + 1;

        const status = node.annotation_status || "unknown";
        stats.byStatus[status] = (stats.byStatus[status] || 0) + 1;

        // meta_json kann als TEXT oder JSON in DB liegen → robust parsen
        let meta: any = null;

        try {
          meta = typeof node.meta_json === "string"
            ? JSON.parse(node.meta_json)
            : node.meta_json;
        } catch {
          meta = null;
        }

        if (meta?.quality?.confidence !== undefined) {
          const c = Number(meta.quality.confidence);
          if (!isNaN(c)) {
            totalConfidence += c;
            nodesWithConfidence++;
          }
        }
      }

      const totalNodes = await this.getTotalNodeCount();
      stats.annotationProgress = totalNodes > 0
        ? (nodes.length / totalNodes) * 100
        : 0;

      stats.averageConfidence = nodesWithConfidence > 0
        ? totalConfidence / nodesWithConfidence
        : 0;

      return stats;

    } catch (error) {
      console.error("Error getting node statistics:", error);
      throw error;
    }
  }

  async getTotalNodeCount(): Promise<number> {
    const result = await db.get<any>(`
      SELECT COUNT(*) AS count 
      FROM functions_nodes
    `);
    return Number(result?.count || 0);
  }

  async getBatchOperations(limit: number = 50): Promise<BatchOperation[]> {
    try {
      const rows = await db.all<any>(`
        SELECT * 
        FROM batch_operations 
        ORDER BY created_at DESC 
        LIMIT ?
      `, [limit]);

      return rows.map(row => {
        let filters: any = {};
        let options: any = {};

        try {
          filters = JSON.parse(row.filters);
        } catch {
          filters = {};
        }

        try {
          options = JSON.parse(row.options);
        } catch {
          options = {};
        }

        return {
          ...row,
          filters,
          options
        };
      });

    } catch (error) {
      console.error("Error getting batch operations:", error);
      return [];
    }
  }

  async saveBatchOperation(operation: BatchOperation): Promise<string> {
    const id =
      operation.id ||
      `batch_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;

    await db.run(`
      INSERT OR REPLACE INTO batch_operations
      (id, operation, filters, options, status, progress, created_at)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `, [
      id,
      operation.operation,
      JSON.stringify(operation.filters ?? {}),
      JSON.stringify(operation.options ?? {}),
      operation.status || "pending",
      operation.progress || 0,
      operation.created_at || new Date().toISOString()
    ]);

    return id;
  }

  async updateBatchProgress(
    id: string,
    progress: number,
    status?: string
  ): Promise<void> {
    const updates: string[] = ["progress = ?"];
    const params: any[] = [progress];

    if (status) {
      updates.push("status = ?");
      params.push(status);
    }

    if (status === "completed" || status === "failed") {
      updates.push("completed_at = ?");
      params.push(new Date().toISOString());
    }

    params.push(id);

    await db.run(`
      UPDATE batch_operations
      SET ${updates.join(", ")}
      WHERE id = ?
    `, params);
  }

  async cleanupOldBatches(daysToKeep: number = 30): Promise<void> {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysToKeep);

    await db.run(`
      DELETE FROM batch_operations
      WHERE created_at < ?
    `, [cutoff.toISOString()]);
  }
}


// ============ ERWEITERTER HAUPTSERVICE ============

export class AiAnnotatorService extends EventEmitter {
  private provider: AIProvider;
  private currentModel: string;
  private availableModels: ModelConfig[];
  private isLargeModel: boolean;
  private errorCorrection: ErrorCorrectionConfig;
  private databaseTool: DatabaseTool;
  private activeBatches: Map<string, BatchOperation> = new Map();

  constructor() {
    super();
    this.provider = "ollama";
    this.currentModel = DEFAULT_AI_MODEL;
    this.availableModels = this.initializeModels();
    this.isLargeModel = this.detectModelCapabilities();
    this.errorCorrection = this.initializeErrorCorrection();
    this.databaseTool = DatabaseTool.getInstance();
    
    this.setupEventHandlers();
  }

  private setupEventHandlers() {
    this.on('batch_progress', (batchId: string, progress: number) => {
      this.databaseTool.updateBatchProgress(batchId, progress);
    });

    this.on('batch_complete', (batchId: string) => {
      this.databaseTool.updateBatchProgress(batchId, 100, 'completed');
      this.activeBatches.delete(batchId);
    });

    this.on('batch_error', (batchId: string, error: Error) => {
      this.databaseTool.updateBatchProgress(batchId, 0, 'failed');
      this.activeBatches.delete(batchId);
    });
  }

  private initializeModels(): ModelConfig[] {
    const models: ModelConfig[] = [

            {
        name: "qwen3:4b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms"],
        maxTokens: 32768,
        contextWindow: 32768,
        speed: "medium",
        accuracy: "medium",
        available: true
      },
      {
        name: "qwen2.5:7b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms", "schema", "pii", "complex"],
        maxTokens: 32768,
        contextWindow: 32768,
        speed: "medium",
        accuracy: "high",
        available: true
      },
      {
        name: "qwen2.5:14b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms", "schema", "pii", "complex"],
        maxTokens: 32768,
        contextWindow: 32768,
        speed: "medium",
        accuracy: "high",
        available: true
      },
      {
        name: "llama3.1:8b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms", "schema", "pii"],
        maxTokens: 8192,
        contextWindow: 8192,
        speed: "medium",
        accuracy: "medium",
        available: true
      },
      {
        name: "llama3.1:70b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms", "schema", "pii", "complex"],
        maxTokens: 8192,
        contextWindow: 8192,
        speed: "slow",
        accuracy: "high",
        available: true
      },
      {
        name: "qwen2:7b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms", "schema", "pii"],
        maxTokens: 32768,
        contextWindow: 32768,
        speed: "medium",
        accuracy: "medium",
        available: true
      },
      {
        name: "qwen3:8b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms"],
        maxTokens: 32768,
        contextWindow: 32768,
        speed: "medium",
        accuracy: "medium",
        available: true
      }
    ];

    // Filter only available Ollama models
    return models.filter(model => model.available);
  }

  private detectModelCapabilities(): boolean {
    const model = this.availableModels.find(m => m.name === this.currentModel);
    return model ? model.capabilities.includes("complex") : false;
  }

  private initializeErrorCorrection(): ErrorCorrectionConfig {
    return {
      enabled: true,
      maxRetries: parseInt(process.env.MAX_RETRIES || "3"),
      retryDelay: parseInt(process.env.RETRY_DELAY_MS || "1000"),
      fallbackModels: this.availableModels.map(m => m.name).filter(name => name !== this.currentModel),
      validationRules: (process.env.VALIDATION_RULES || "json,required_fields,business_area").split(","),
      autoCorrect: process.env.AUTO_CORRECT === "true"
    };
  }

// ============ KERN-FUNKTIONEN ============

async listCandidates(opts: {
  kinds?: string[];
  missingOnly?: boolean;
  limit?: number;
  offset?: number;
  search?: string;
  status?: string[];
  businessArea?: string[];
  complexity?: string[];
}): Promise<NodeForAnnotation[]> {
  const limit = Math.max(1, Math.min(10_000, opts.limit ?? 500));
  const offset = Math.max(0, opts.offset ?? 0);

  const params: any[] = [];
  let sql = `
    SELECT id, title, kind, path_json as path,
           meta_json, schema_json, aa_json, source_file,
           created_at, updated_at, last_annotated, annotation_status
    FROM functions_nodes
    WHERE 1 = 1
  `;

  // fehlende Metadaten
  if (opts.missingOnly) {
    sql += ` AND (meta_json IS NULL OR meta_json = '' OR json_type(meta_json) = 'null')`;
  }

  // Filter: kinds
  if (opts.kinds?.length) {
    sql += ` AND kind IN (${opts.kinds.map(() => "?").join(",")})`;
    params.push(...opts.kinds);
  }

  // Filter: Suche in title, id, path_json
  if (opts.search) {
    sql += ` AND (title LIKE ? OR id LIKE ? OR path_json LIKE ?)`;
    const pattern = `%${opts.search}%`;
    params.push(pattern, pattern, pattern);
  }

  // Filter: Status
  if (opts.status?.length) {
    sql += ` AND annotation_status IN (${opts.status.map(() => "?").join(",")})`;
    params.push(...opts.status);
  }

  // Sortierung + Limit + Offset
  sql += ` ORDER BY created_at DESC LIMIT ? OFFSET ?`;
  params.push(limit, offset);

  try {
    const rows = await db.all<any>(sql, params);

    return rows.map((r) => ({
      id: r.id,
      title: r.title,
      kind: r.kind,
      path: typeof r.path === "string" ? this.safeJsonArray(r.path) : r.path,
      meta_json: r.meta_json ?? null,
      schema_json: r.schema_json ?? null,
      aa_json: r.aa_json ?? null,
      source_file: r.source_file ?? null,
      created_at: r.created_at,
      updated_at: r.updated_at,
      last_annotated: r.last_annotated,
      annotation_status: r.annotation_status || "pending"
    }));
  } catch (error) {
    console.error("Database error in listCandidates:", error);
    throw error;
  }
}


// -----------------------------------------------------------
// SAVE META
// -----------------------------------------------------------

async saveMeta(id: string, meta: GeneratedMeta): Promise<void> {
  const now = new Date().toISOString();

  try {
    await db.run(
      `
      UPDATE functions_nodes 
      SET meta_json = ?, 
          updated_at = ?, 
          last_annotated = ?, 
          annotation_status = ?
      WHERE id = ?
    `,
      [
        JSON.stringify(meta),
        now,
        now,
        "completed",
        id
      ]
    );
  } catch (error) {
    console.error(`Failed to save meta for ID ${id}:`, error);
    throw error;
  }
}


// -----------------------------------------------------------
// SAVE RULE – hängt Regel in die vorhandenen Metadaten ein
// -----------------------------------------------------------

async saveRule(id: string, rule: DashboardRule): Promise<void> {
  try {
    const currentMeta = await this.getNodeMeta(id);

    const updatedMeta = {
      ...currentMeta,
      rule,
      last_annotated: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    await this.saveMeta(id, updatedMeta);
  } catch (error) {
    console.error(`Failed to save rule for ${id}:`, error);
    throw error;
  }
}


// -----------------------------------------------------------
// SAVE FORM SPEC – speichert Formular in meta_json
// -----------------------------------------------------------

async saveFormSpec(id: string, formSpec: FormSpec): Promise<void> {
  try {
    const currentMeta = await this.getNodeMeta(id);

    const updatedMeta = {
      ...currentMeta,
      formSpec,
      last_annotated: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    await this.saveMeta(id, updatedMeta);
  } catch (error) {
    console.error(`Failed to save form spec for ${id}:`, error);
    throw error;
  }
}


// -----------------------------------------------------------
// Kleine Hilfsfunktion: Sicheres JSON-Array-Parsing
// -----------------------------------------------------------

private safeJsonArray(value: string): string[] {
  try {
    const parsed = JSON.parse(value);
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
}


  // ============ KI-GENERIERUNG ============

async generateMeta(node: NodeForAnnotation, retryCount = 0): Promise<GeneratedMeta> {
  const op = "meta";
  const modelBefore = this.currentModel;

  if (retryCount >= this.errorCorrection.maxRetries) {
    throw new Error(`Max retries exceeded for meta generation for node ${node.id}`);
  }

  const start = Date.now();
  console.log(`[AI][${op}] start – Modell: ${modelBefore}`);
  console.log(`[AI][${op}] Node: ${node.id}`);
  console.log(`[AI][${op}] Operation: ${op}`);

  try {
    const prompt = this.isLargeModel
      ? this.buildEnhancedMetaPrompt(node)
      : this.buildSimpleMetaPrompt(node);

    const raw = await this.callAI(prompt, op);
    const meta = this.parseMetaJson(raw, node);

    const validation = this.validateMeta(meta);
    if (!validation.valid && this.errorCorrection.autoCorrect) {
      console.warn(`[AI][${op}] Validation failed, correction required`);
      return await this.correctMetaGeneration(node, meta, validation.errors, retryCount);
    }

    console.log(`[AI][${op}] done – ${Date.now() - start} ms`);

    return {
      ...meta,
      quality: {
        confidence: meta.quality?.confidence ?? 0.5,
        evidence: meta.quality?.evidence ?? ["Automatisch generiert"],
        generatedBy: "ai",
        modelUsed: this.currentModel,
      },
    };

  } catch (error) {
    console.warn(`[AI][${op}] failed – retry ${retryCount + 1}`, error);

    if (this.errorCorrection.enabled && retryCount < this.errorCorrection.maxRetries) {
      await this.delay(this.errorCorrection.retryDelay * (retryCount + 1));
      return this.generateMeta(node, retryCount + 1);
    }

    throw error;
  }
}

async generateRule(node: NodeForAnnotation, retryCount = 0): Promise<DashboardRule> {
  const op = "rule";
  const modelBefore = this.currentModel;

  if (retryCount >= this.errorCorrection.maxRetries) {
    throw new Error(`Max retries exceeded for rule generation for node ${node.id}`);
  }

  const start = Date.now();
  console.log(`[AI][${op}] start – Modell: ${modelBefore}`);
  console.log(`[AI][${op}] Node: ${node.id}`);
  console.log(`[AI][${op}] Operation: ${op}`);

  try {
    const prompt = this.buildRulePrompt(node);
    const raw = await this.callAI(prompt, op);
    const rule = this.parseRuleJson(raw);

    console.log(`[AI][${op}] done – ${Date.now() - start} ms`);
    return rule;

  } catch (error) {
    console.warn(`[AI][${op}] failed – retry ${retryCount + 1}`, error);

    if (this.errorCorrection.enabled && retryCount < this.errorCorrection.maxRetries) {
      await this.delay(this.errorCorrection.retryDelay * (retryCount + 1));
      return this.generateRule(node, retryCount + 1);
    }

    throw error;
  }
}

async generateFormSpec(node: NodeForAnnotation, retryCount = 0): Promise<FormSpec> {
  const op = "form";
  const modelBefore = this.currentModel;

  if (retryCount >= this.errorCorrection.maxRetries) {
    throw new Error(`Max retries exceeded for form generation for node ${node.id}`);
  }

  const start = Date.now();
  console.log(`[AI][${op}] start – Modell: ${modelBefore}`);
  console.log(`[AI][${op}] Node: ${node.id}`);
  console.log(`[AI][${op}] Operation: ${op}`);

  try {
    const prompt = this.buildFormPrompt(node);
    const raw = await this.callAI(prompt, op);
    const form = this.parseFormJson(raw);

    console.log(`[AI][${op}] done – ${Date.now() - start} ms`);
    return form;

  } catch (error) {
    console.warn(`[AI][${op}] failed – retry ${retryCount + 1}`, error);

    if (this.errorCorrection.enabled && retryCount < this.errorCorrection.maxRetries) {
      await this.delay(this.errorCorrection.retryDelay * (retryCount + 1));
      return this.generateFormSpec(node, retryCount + 1);
    }

    throw error;
  }
}

async enhanceSchema(node: NodeForAnnotation): Promise<any> {
  const op = "schema";
  const start = Date.now();

  console.log(`[AI][${op}] start – Modell: ${this.currentModel}`);
  console.log(`[AI][${op}] Node: ${node.id}`);
  console.log(`[AI][${op}] Operation: ${op}`);

  try {
    const prompt = this.buildSchemaEnhancementPrompt(node);
    const raw = await this.callAI(prompt, op);
    console.log(`[AI][${op}] done – ${Date.now() - start} ms`);
    return JSON.parse(raw);

  } catch (error) {
    console.warn(`[AI][${op}] failed`, error);
    throw error;
  }
}

async classifyPii(nodes: NodeForAnnotation[]): Promise<PiiResult[]> {
  const op = "pii";
  const start = Date.now();

  console.log(`[AI][${op}] start – Modell: ${this.currentModel}`);
  console.log(`[AI][${op}] Nodes: ${nodes.length}`);
  console.log(`[AI][${op}] Operation: ${op}`);

  try {
    const prompt = this.buildPiiClassificationPrompt(nodes);
    const raw = await this.callAI(prompt, op);
    const result = this.parsePiiClassification(raw, nodes);

    console.log(`[AI][${op}] done – ${Date.now() - start} ms`);
    return result;

  } catch (error) {
    console.warn(`[AI][${op}] failed`, error);
    throw error;
  }
}


// ============ AI-CALLS ============

private async callAI(prompt: string, operation: string): Promise<string> {
  const model = this.selectModelForOperation(operation);
  this.currentModel = model.name;

  console.log(`[AI][${operation}] -> Starte AI-Aufruf mit Modell: ${model.name}`);

  try {
    return await this.callOllama(prompt, model.name);
  } catch (error) {
    console.warn(`[AI][${operation}] Fehler beim Modell ${model.name}`);
    return await this.fallbackAI(prompt, operation, error);
  }
}

private async callOllama(prompt: string, model: string): Promise<string> {
  const baseUrl = process.env.OLLAMA_BASE_URL || "http://localhost:11434";

  console.log(`[Ollama] Prüfe Modell "${model}"`);

  try {
    const modelsResponse = await fetch(`${baseUrl}/api/tags`);
    if (!modelsResponse.ok) {
      throw new Error(`/api/tags HTTP ${modelsResponse.status}`);
    }

    const modelsData = await modelsResponse.json();
    const available = Array.isArray(modelsData.models)
      ? modelsData.models.map((m: any) => m.name)
      : [];

    if (!available.includes(model)) {
      console.warn(`[Ollama] Modell "${model}" nicht lokal – lade herunter…`);

      const pullResp = await fetch(`${baseUrl}/api/pull`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: model, stream: false }),
      });

      if (!pullResp.ok) {
        const msg = await pullResp.text().catch(() => "");
        throw new Error(`Ollama Pull-Fehler ${pullResp.status}: ${msg}`);
      }

      const result = await pullResp.json().catch(() => ({}));
      if (result.error) throw new Error(`Ollama Pull meldet Fehler: ${result.error}`);

      console.log(`[Ollama] Modell "${model}" erfolgreich geladen`);
    }
  } catch (error: any) {
    console.warn(`[Ollama] Modellprüfung/Download fehlgeschlagen: ${error.message || error}`);
  }

  console.log(`[Ollama] Generiere Antwort mit "${model}"`);

  const resp = await fetch(`${baseUrl}/api/generate`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      model,
      prompt,
      stream: false,
      options: {
        temperature: 0.1,
        top_p: 0.9,
        num_predict: 4000
      }
    }),
  });

  if (!resp.ok) {
    const text = await resp.text().catch(() => "");
    throw new Error(`Ollama HTTP ${resp.status}: ${text}`);
  }

  const data = await resp.json();
  return data.response || "{}";
}

private async fallbackAI(prompt: string, operation: string, originalError: any): Promise<string> {
  console.warn(`[AI][${operation}] Fallback notwendig:`, originalError);

  const list = this.errorCorrection.fallbackModels;

  let pos = list.indexOf(this.currentModel);
  if (pos === -1) pos = 0;

  if (pos < list.length - 1) {
    const next = list[pos + 1];
    console.log(`[AI][${operation}] Versuche Fallback-Modell: ${next}`);
    this.currentModel = next;
    return this.callOllama(prompt, next);
  }

  throw new Error(`[AI][${operation}] Alle Fallback-Modelle fehlgeschlagen`);
}


// ============ PROMPT-BUILDING (Qwen-Optimiert, ERP-Vertieft) ============

private buildEnhancedMetaPrompt(node: NodeForAnnotation): string {
  return (
`SYSTEM:
Du bist ein ERP-Analysemodell. Deine Aufgabe ist es, präzise geschäftliche und technische Metadaten zu erzeugen.
Antwort immer in reinem JSON. Keine Erklärungen. Kein Markdown. Keine Backticks.

Anforderungen:
- Liefere ausschließlich gültiges JSON.
- Halte dich exakt an die geforderten Property-Namen.
- Verwende nur definierte Wertebereiche.
- Keine zusätzlichen Felder.
- Beschreibungen müssen realistisch, fachlich fundiert und ERP-typisch sein.
- Wenn du etwas nicht sicher weißt: konservativ bleiben und nachvollziehbare Annahmen treffen.

ERP-Domänenwissen:
- Typische Module: Finanzen, Vertrieb, Einkauf, Produktion, Lager/Logistik, HR, IT.
- Typische Aufgaben: Buchungen, Bewegungen, Stammdaten, Auswertungen, Workflows.
- PII-Bewertung basiert auf Art der Daten (Kunden, Mitarbeiter, Lieferanten usw.).

OUTPUT-SCHEMA:
{
  "description": "string (2-5 Sätze, faktenbasiert, ERP-kontextualisiert)",
  "tags": ["string"],
  "businessArea": "Finanzen|Vertrieb|Einkauf|HR|Produktion|IT|Logistik|Marketing|Allgemein",
  "piiClass": "none|low|medium|high",
  "requires": ["string"],
  "technical": {
    "complexity": "low|medium|high",
    "dataVolume": "small|medium|large",
    "integrationPoints": ["string"],
    "performanceImpact": "low|medium|high",
    "databaseOperations": ["read|write|delete|aggregate"],
    "dataEntities": ["string"],
    "expectedRecordCount": "low|medium|high"
  },
  "compliance": {
    "gdprRelevant": boolean,
    "retentionPeriodDays": number,
    "auditRequired": boolean,
    "riskFactors": ["string"]
  },
  "quality": {
    "confidence": number,
    "evidence": ["string"]
  }
}

KNOTENDATEN:
` +
JSON.stringify({
  id: node.id,
  title: node.title,
  kind: node.kind,
  path: node.path,
  hasSchema: !!node.schema_json,
  hasWorkflow: !!node.aa_json,
  schemaFields: node.schema_json ? Object.keys(node.schema_json).slice(0, 25) : [],
  workflow: node.aa_json ? Object.keys(node.aa_json) : []
}, null, 2)
);
}

private buildSimpleMetaPrompt(node: NodeForAnnotation): string {
  return (
`SYSTEM:
Du bist ein ERP-Analysemodell. Antwort ausschließlich in gültigem JSON.

OUTPUT:
{
  "description": "string",
  "tags": ["string"],
  "businessArea": "Finanzen|Vertrieb|Einkauf|HR|Produktion|IT|Logistik|Marketing|Allgemein",
  "piiClass": "none|low|medium|high",
  "quality": { "confidence": number }
}

KONTEXT:
` + JSON.stringify({
    title: node.title,
    kind: node.kind,
    path: node.path
  }, null, 2)
  );
}

private buildRulePrompt(node: NodeForAnnotation): string {
  return (
`SYSTEM:
Erzeuge eine Dashboard-Regel für ERP-Analytics. Antworte nur mit JSON.

OUTPUT-SCHEMA:
{
  "type": "dashboard-root|section|metric|report|form|table|action|config|chart|kpi|alerts",
  "widget": "number|chart|gauge|table|form|button|tabs|grid|panel|progress|timeline|map",
  "dataSource": "string|null",
  "refreshInterval": number,
  "unit": "string|null",
  "permissions": ["string"],
  "layout": {
    "colSpan": number,
    "rowSpan": number,
    "priority": number,
    "responsive": boolean
  },
  "aggregation": "sum|avg|max|min|count|null",
  "timeRange": "day|week|month|year|null",
  "colorScheme": "default|green|red|blue|neutral"
}

KNOTEN:
` +
JSON.stringify({
  title: node.title,
  path: node.path,
  kind: node.kind,
  tags: node.meta_json?.tags || []
}, null, 2)
  );
}

private buildFormPrompt(node: NodeForAnnotation): string {
  return (
`SYSTEM:
Erzeuge ERP-Formulardaten in gültigem JSON. Keine Kommentare. Keine Backticks.

OUTPUT-SCHEMA:
{
  "title": "string",
  "description": "string",
  "layout": "vertical|horizontal|wizard|tabs|accordion",
  "fields": [
    {
      "name": "string",
      "type": "text|number|date|select|checkbox|textarea|email|phone|currency|percentage",
      "label": "string",
      "required": boolean,
      "options": ["string"],
      "placeholder": "string",
      "defaultValue": "any"
    }
  ],
  "sections": [
    {
      "title": "string",
      "fields": ["string"]
    }
  ],
  "validation": [
    {
      "field": "string",
      "type": "required|min|max|pattern|custom"
    }
  ],
  "actions": ["string"]
}

KONTEXT:
` +
JSON.stringify({
  title: node.title,
  path: node.path,
  kind: node.kind
}, null, 2)
  );
}

private buildSchemaEnhancementPrompt(node: NodeForAnnotation): string {
  return (
`SYSTEM:
Verbessere das Schema einer ERP-Funktion. Antwort ausschließlich in JSON.

REGELN:
- Keine zusätzlichen Texte
- Kein Markdown
- Nur JSON
- Struktur konsistent halten

AKTUELLES-SCHEMA:
` +
JSON.stringify(node.schema_json || {}, null, 2)
  );
}

private buildPiiClassificationPrompt(nodes: NodeForAnnotation[]): string {
  return (
`SYSTEM:
Klassifiziere das PII-Risiko für ERP-Funktionen. Ausgabe NUR als JSON-Array.

EINTRAG-SCHEMA:
{
  "id": "string",
  "piiClass": "none|low|medium|high",
  "reason": "string",
  "confidence": number
}

DATEN:
` +
JSON.stringify(
  nodes.map(n => ({
    id: n.id,
    title: n.title,
    kind: n.kind,
    path: n.path
  })),
  null,
  2
)
  );
}

private buildCorrectionPrompt(
  node: NodeForAnnotation,
  invalidMeta: GeneratedMeta,
  errors: string[]
): string {
  return (
`SYSTEM:
Korrigiere Metadaten. Erzeuge ausschließlich gültiges JSON.

FEHLER:
` + JSON.stringify(errors, null, 2) +
`
ORIGINAL:
` + JSON.stringify(invalidMeta, null, 2) +
`
KONTEXT:
` + JSON.stringify({
      id: node.id,
      title: node.title,
      kind: node.kind,
      path: node.path
    }, null, 2)
  );
}


// ============ PARSING ============

private parseMetaJson(raw: string, node: NodeForAnnotation): GeneratedMeta {
  let parsed: any = {};

  try {
    parsed = JSON.parse(raw);
  } catch {
    const match = raw.match(/\{[\s\S]*\}/);
    if (match) {
      try {
        parsed = JSON.parse(match[0]);
      } catch (err) {
        console.warn("parseMetaJson: JSON parsing failed:", err);
        throw new Error("Invalid JSON response from AI");
      }
    }
  }

  return {
    description:
      typeof parsed.description === "string" && parsed.description.trim() !== ""
        ? parsed.description
        : `Automatisch generierte Beschreibung für ${node.title}`,

    tags:
      Array.isArray(parsed.tags) && parsed.tags.length > 0
        ? parsed.tags.filter((t: any) => typeof t === "string").slice(0, 10)
        : [node.kind, ...node.title.split(" ").slice(0, 3)],

    businessArea:
      typeof parsed.businessArea === "string"
        ? parsed.businessArea
        : this.guessBusinessArea(node),

    piiClass:
      typeof parsed.piiClass === "string"
        ? parsed.piiClass
        : this.guessPiiClass(node),

    requires:
      Array.isArray(parsed.requires)
        ? parsed.requires.filter((r: any) => typeof r === "string")
        : [],

    quality: {
      confidence:
        typeof parsed?.quality?.confidence === "number"
          ? parsed.quality.confidence
          : 0.5,

      evidence:
        Array.isArray(parsed?.quality?.evidence)
          ? parsed.quality.evidence.filter((e: any) => typeof e === "string")
          : ["Automatisch generiert"],

      generatedBy: "ai",
      modelUsed: this.currentModel,
    },

    technical:
      typeof parsed.technical === "object" && parsed.technical !== null
        ? {
            complexity:
              parsed.technical.complexity || "medium",
            dataVolume:
              parsed.technical.dataVolume || "medium",
            integrationPoints:
              Array.isArray(parsed.technical.integrationPoints)
                ? parsed.technical.integrationPoints.filter((x: any) => typeof x === "string")
                : [],
            performanceImpact:
              parsed.technical.performanceImpact || "medium",
          }
        : this.analyzeTechnicalComplexity(node),

    compliance:
      typeof parsed.compliance === "object" && parsed.compliance !== null
        ? {
            gdprRelevant: !!parsed.compliance.gdprRelevant,
            auditRequired: !!parsed.compliance.auditRequired,
            retentionPeriod: parsed.compliance.retentionPeriod ?? undefined,
          }
        : { gdprRelevant: false, auditRequired: false },
  };
}

private parseRuleJson(raw: string): DashboardRule {
  let obj: any;

  try {
    obj = JSON.parse(raw);
  } catch {
    const match = raw.match(/\{[\s\S]*\}/);
    if (!match) throw new Error("Invalid rule JSON response from AI");
    obj = JSON.parse(match[0]);
  }

  const validTypes = [
    "dashboard-root", "section", "metric", "report",
    "form", "table", "action", "config", "chart",
    "kpi", "alerts"
  ];

  const validWidgets = [
    "number", "chart", "gauge", "table",
    "form", "button", "tabs", "grid",
    "panel", "progress", "timeline", "map"
  ];

  return {
    type: validTypes.includes(obj.type) ? obj.type : "section",
    widget: validWidgets.includes(obj.widget) ? obj.widget : undefined,
    dataSource: typeof obj.dataSource === "string" ? obj.dataSource : undefined,
    refreshInterval: typeof obj.refreshInterval === "number" ? obj.refreshInterval : undefined,
    unit: typeof obj.unit === "string" ? obj.unit : undefined,
    permissions: Array.isArray(obj.permissions) ? obj.permissions : [],
    layout:
      typeof obj.layout === "object" && obj.layout !== null
        ? {
            colSpan: obj.layout.colSpan ?? 1,
            rowSpan: obj.layout.rowSpan ?? 1,
            priority: obj.layout.priority ?? 1,
          }
        : { colSpan: 1, rowSpan: 1, priority: 1 },
    aggregation: obj.aggregation,
    timeRange: obj.timeRange,
    colorScheme: obj.colorScheme
  };
}

private parseFormJson(raw: string): FormSpec {
  let obj: any;
  try {
    obj = JSON.parse(raw);
  } catch {
    const match = raw.match(/\{[\s\S]*\}/);
    if (!match) throw new Error("Invalid form JSON response from AI");
    obj = JSON.parse(match[0]);
  }

  return {
    title: obj.title || "Formular",
    fields: Array.isArray(obj.fields) ? obj.fields : [],
    layout: obj.layout || "vertical",
    validation: Array.isArray(obj.validation) ? obj.validation : [],
    actions: Array.isArray(obj.actions) ? obj.actions : ["speichern", "abbrechen"]
  };
}

private parsePiiClassification(raw: string, nodes: NodeForAnnotation[]): PiiResult[] {
  let obj: any;

  try {
    obj = JSON.parse(raw);
  } catch {
    const match = raw.match(/\[[\s\S]*\]/);
    if (!match) throw new Error("Invalid PII classification response");
    obj = JSON.parse(match[0]);
  }

  if (!Array.isArray(obj)) throw new Error("PII response must be array");

  return obj.map((item: any) => ({
    id: item.id,
    piiClass:
      ["none", "low", "medium", "high"].includes(item.piiClass)
        ? item.piiClass
        : "none",
    reason: item.reason || "Automatisch klassifiziert",
    confidence: Math.min(1, Math.max(0, Number(item.confidence ?? 0.5))),
    generatedBy: "ai",
  }));
}


// ============ VALIDATION ============

private validateMeta(meta: GeneratedMeta): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // --- description ---
  if (typeof meta.description !== "string" || meta.description.trim().length < 15) {
    errors.push("Description is missing or too short (minimum 15 characters).");
  }

  // --- tags ---
  if (!Array.isArray(meta.tags) || meta.tags.length < 2) {
    errors.push("At least two tags must be provided.");
  } else {
    const invalidTags = meta.tags.filter(t => typeof t !== "string" || t.trim() === "");
    if (invalidTags.length > 0) {
      errors.push(`Tags contain invalid entries: ${invalidTags.join(", ")}`);
    }
  }

  // --- businessArea ---
  const validBusinessAreas = [
    "Finanzen", "Vertrieb", "Einkauf", "HR", "Produktion",
    "IT", "Logistik", "Marketing", "Allgemein"
  ];

  if (!meta.businessArea || !validBusinessAreas.includes(meta.businessArea)) {
    errors.push(
      `Invalid or missing businessArea. Got "${meta.businessArea}". Expected one of: ${validBusinessAreas.join(", ")}.`
    );
  }

  // --- piiClass ---
  const validPii = ["none", "low", "medium", "high"] as const;

  if (!meta.piiClass || typeof meta.piiClass !== "string") {
    errors.push("piiClass is missing.");
  } else if (!validPii.includes(meta.piiClass as any)) {
    errors.push(`Invalid piiClass "${meta.piiClass}". Expected: ${validPii.join(", ")}.`);
  }


  // --- requires ---
  if (!Array.isArray(meta.requires)) {
    errors.push("Requires must be an array.");
  } else {
    const invalidReq = meta.requires.filter(r => typeof r !== "string");
    if (invalidReq.length > 0) {
      errors.push(`Requires contains non-string values: ${invalidReq.join(", ")}`);
    }
  }

  // --- technical ---
  if (!meta.technical) {
    errors.push("Missing technical section.");
  } else {
    if (!["low", "medium", "high"].includes(meta.technical.complexity)) {
      errors.push(`Invalid technical.complexity "${meta.technical.complexity}".`);
    }
    if (!["small", "medium", "large"].includes(meta.technical.dataVolume)) {
      errors.push(`Invalid technical.dataVolume "${meta.technical.dataVolume}".`);
    }
    if (!["low", "medium", "high"].includes(meta.technical.performanceImpact)) {
      errors.push(`Invalid technical.performanceImpact "${meta.technical.performanceImpact}".`);
    }
    if (!Array.isArray(meta.technical.integrationPoints)) {
      errors.push("technical.integrationPoints must be an array.");
    }
  }

  // --- compliance ---
  if (!meta.compliance) {
    errors.push("Missing compliance section.");
  } else {
    if (typeof meta.compliance.gdprRelevant !== "boolean") {
      errors.push("compliance.gdprRelevant must be boolean.");
    }
    if (typeof meta.compliance.auditRequired !== "boolean") {
      errors.push("compliance.auditRequired must be boolean.");
    }
    if (
      meta.compliance.retentionPeriod !== undefined &&
      (typeof meta.compliance.retentionPeriod !== "number" ||
        meta.compliance.retentionPeriod < 0)
    ) {
      errors.push("Invalid compliance.retentionPeriod (must be positive number).");
    }
  }

  // ---- quality ----
  if (!meta.quality) {
    errors.push("Missing quality section.");
  } else {
    if (
      typeof meta.quality.confidence !== "number" ||
      meta.quality.confidence < 0 ||
      meta.quality.confidence > 1
    ) {
      errors.push("quality.confidence must be between 0 and 1.");
    }

    if (!Array.isArray(meta.quality.evidence)) {
      errors.push("quality.evidence must be an array.");
    }
  }

  // Rückgabe
  return { valid: errors.length === 0, errors };
}


// ============ BATCH OPERATIONS ============

async executeBatchOperation(operation: BatchOperation): Promise<BatchResult> {
  const batchId = await this.databaseTool.saveBatchOperation({
    ...operation,
    status: "running",
    started_at: new Date().toISOString(),
    progress: 0
  });

  this.activeBatches.set(batchId, operation);

  console.log(`\n[BATCH] Start "${operation.operation}" – ID=${batchId}`);
  console.log(`[BATCH] Filter:`, operation.filters);
  console.log(`[BATCH] Options:`, operation.options || {});

  try {
    const nodes = await this.listCandidates(operation.filters);

    console.log(`[BATCH] ${nodes.length} Nodes geladen.`);

    const result: BatchResult = {
      id: batchId,
      total: nodes.length,
      processed: 0,
      successful: 0,
      failed: 0,
      errors: [],
      results: []
    };

    const chunkSize = operation.options?.chunkSize || 10;

    for (let i = 0; i < nodes.length; i += chunkSize) {
      const chunk = nodes.slice(i, i + chunkSize);

      console.log(
        `[BATCH] Chunk ${i / chunkSize + 1}: ${chunk.length} Nodes`
      );

      const chunkPromises = chunk.map(async (node, index) => {
        await this.delay(index * 100);
        return this.processBatchNode(node, operation, batchId);
      });

      const chunkResults = await Promise.allSettled(chunkPromises);

      chunkResults.forEach((settled, idx) => {
        const node = chunk[idx];

        if (settled.status === "fulfilled") {
          const nodeResult = settled.value;

          result.results.push(nodeResult);

          if (nodeResult.success) {
            result.successful++;
          } else {
            result.failed++;
            result.errors.push(`${node.id}: ${nodeResult.error}`);
          }

        } else {
          result.results.push({
            id: node.id,
            success: false,
            error: settled.reason?.message || "Unknown error",
            retries: 0
          });

          result.failed++;
          result.errors.push(`${node.id}: ${settled.reason?.message}`);
        }

        result.processed++;
      });

      const progress = Math.round((result.processed / result.total) * 100);
      this.emit("batch_progress", batchId, progress);

      console.log(`[BATCH] Progress: ${progress}%`);
      await this.delay(300);
    }

    result.summary = this.calculateBatchSummary(result);

    console.log(
      `[BATCH] Completed – Success=${result.successful}, Failed=${result.failed}`
    );

    this.emit("batch_complete", batchId);
    return result;

  } catch (error) {
    console.error(`[BATCH] ERROR:`, error);
    this.emit("batch_error", batchId, error as Error);
    throw error;
  }
}

private async processBatchNode(
  node: NodeForAnnotation,
  operation: BatchOperation,
  batchId: string
): Promise<BatchResult["results"][0]> {
  const start = Date.now();
  let retries = 0;
  const maxRetries = operation.options?.maxRetries || this.errorCorrection.maxRetries;

  console.log(`[BATCH][Node ${node.id}] Start – Operation=${operation.operation}`);

  while (retries <= maxRetries) {
    try {
      let result: any;

      switch (operation.operation) {
        case "generate_meta":
          result = await this.generateMeta(node);
          await this.saveMeta(node.id, result);
          break;

        case "generate_forms":
          result = await this.generateFormSpec(node);
          await this.saveFormSpec(node.id, result);
          break;

        case "enhance_schema":
          result = await this.enhanceSchema(node);
          break;

        case "classify_pii":
          result = (await this.classifyPii([node]))[0];
          break;

        case "generate_rule":
          result = await this.generateRule(node);
          await this.saveRule(node.id, result);
          break;

        case "full_annotation":
          const [meta, rule, form] = await Promise.all([
            this.generateMeta(node),
            this.generateRule(node),
            this.generateFormSpec(node)
          ]);

          result = { meta, rule, form };

          await this.saveMeta(node.id, { ...meta, rule } as any);
          await this.saveFormSpec(node.id, form);
          break;

        case "validate_nodes":
          result = await this.validateNode(node);
          break;
      }

      console.log(
        `[BATCH][Node ${node.id}] Success – ${Date.now() - start}ms (Retries=${retries})`
      );

      return {
        id: node.id,
        success: true,
        result,
        retries,
        duration: Date.now() - start
      };

    } catch (err) {
      retries++;
      const msg =
        err instanceof Error ? err.message : "Unknown error occurred";

      console.warn(
        `[BATCH][Node ${node.id}] Fehler: ${msg} (Retry ${retries}/${maxRetries})`
      );

      if (retries > maxRetries) {
        return {
          id: node.id,
          success: false,
          error: msg,
          retries,
          duration: Date.now() - start
        };
      }

      await this.delay(this.errorCorrection.retryDelay * retries);
    }
  }

  return {
    id: node.id,
    success: false,
    error: "Max retries exceeded",
    retries,
    duration: Date.now() - start
  };
}


// ============ UTILITY METHODS ============

/**
 * Modellwahl für eine Operation
 * Bevorzugt:
 *   1. qwen3:8b
 *   2. qwen3:4b
 *   3. alle anderen fähigen Modelle
 */
private selectModelForOperation(operation: string): ModelConfig {
  const hasCapability = (m: ModelConfig) =>
    m.capabilities.includes(operation) || m.capabilities.includes("complex");

  const candidates = this.availableModels.filter(hasCapability);

  if (candidates.length === 0) {
    throw new Error(
      `[aiAnnotator] Kein Ollama-Modell unterstützt Operation "${operation}".`
    );
  }

  // Priorisierte Reihenfolge
  const priorityOrder = ["qwen3:8b", "qwen3:4b"];

  for (const preferred of priorityOrder) {
    const model = candidates.find((m) => m.name === preferred);
    if (model) {
      console.log(
        `[AI][Select] Operation "${operation}": verwende bevorzugtes Modell ${model.name}`
      );
      this.currentModel = model.name;
      return model;
    }
  }

  // Falls aktuelles Modell gültig ist → behalten
  const current = candidates.find((m) => m.name === this.currentModel);
  if (current) {
    console.log(
      `[AI][Select] Operation "${operation}": nutze aktuelles Modell ${current.name}`
    );
    return current;
  }

  // Allgemeiner Fallback auf erstes verfügbares
  console.log(
    `[AI][Select] Operation "${operation}": fallback → ${candidates[0].name}`
  );
  this.currentModel = candidates[0].name;
  return candidates[0];
}

private delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Meta-Korrektur mit KI-Feedback
 */
private async correctMetaGeneration(
  node: NodeForAnnotation,
  invalidMeta: GeneratedMeta,
  errors: string[],
  retryCount: number
): Promise<GeneratedMeta> {
  console.warn(
    `[AI][MetaCorrection] Node=${node.id} – Fehler: ${errors.join(", ")}`
  );

  const correctionPrompt = this.buildCorrectionPrompt(
    node,
    invalidMeta,
    errors
  );

  try {
    const raw = await this.callAI(correctionPrompt, "correction");
    const corrected = this.parseMetaJson(raw, node);

    return {
      ...corrected,
      quality: {
        confidence:
          corrected.quality?.confidence ?? invalidMeta.quality?.confidence ?? 0.5,
        evidence: [
          ...(corrected.quality?.evidence || []),
          `Corrected due to: ${errors.join(", ")}`
        ],
        generatedBy: "ai",
        modelUsed: this.currentModel
      }
    };
  } catch (error) {
    console.warn(
      `[AI][MetaCorrection] Failed for Node=${node.id} – retry=${retryCount}`
    );
    throw error;
  }
}

/**
 * Zusammenfassung eines Batch-Laufs
 */
private calculateBatchSummary(
  result: BatchResult
): BatchResult["summary"] {
  const confidences: number[] = [];

  const businessAreas: Record<string, number> = {};
  const piiDistribution: Record<string, number> = {};

  for (const r of result.results) {
    if (!r.success || !r.result) continue;

    // Confidence sammeln
    const c =
      r.result?.quality?.confidence ??
      r.result?.meta?.quality?.confidence ??
      undefined;

    if (typeof c === "number") confidences.push(c);

    // Business Area
    const area =
      r.result.businessArea ||
      r.result.meta?.businessArea ||
      "Unknown";

    businessAreas[area] = (businessAreas[area] || 0) + 1;

    // PII
    const pii =
      r.result.piiClass ||
      r.result.meta?.piiClass ||
      "none";

    piiDistribution[pii] = (piiDistribution[pii] || 0) + 1;
  }

  const avg =
    confidences.length > 0
      ? confidences.reduce((a, b) => a + b, 0) / confidences.length
      : 0;

  return {
    averageConfidence: avg,
    businessAreas,
    piiDistribution,
    qualityScore:
      result.total > 0 ? result.successful / result.total : 0
  };
}


// ============ HELPER METHODS ============

private analyzeTechnicalComplexity(
  node: NodeForAnnotation
): GeneratedMeta["technical"] {
  const title = (node.title || "").toLowerCase();

  let complexity: "low" | "medium" | "high" = "low";
  let dataVolume: "small" | "medium" | "large" = "small";
  let performanceImpact: "low" | "medium" | "high" = "low";

  if (
    title.includes("report") ||
    title.includes("analyse") ||
    title.includes("statistik")
  ) {
    dataVolume = "large";
    performanceImpact = "medium";
  }

  if (
    title.includes("transaktion") ||
    title.includes("buchung") ||
    title.includes("rechnung")
  ) {
    complexity = "medium";
    performanceImpact = "medium";
  }

  if (
    title.includes("integration") ||
    title.includes("synchronisation") ||
    title.includes("api")
  ) {
    complexity = "high";
    performanceImpact = "high";
  }

  return {
    complexity,
    dataVolume,
    integrationPoints: this.extractIntegrationPoints(node),
    performanceImpact
  };
}

private extractIntegrationPoints(node: NodeForAnnotation): string[] {
  const integrations: string[] = [];

  const title = (node.title || "").toLowerCase();
  const path = Array.isArray(node.path)
    ? node.path.join(" ").toLowerCase()
    : "";

  if (title.includes("kunde") || path.includes("kunde"))
    integrations.push("CRM");
  if (title.includes("lieferant") || path.includes("lieferant"))
    integrations.push("Lieferantenmanagement");
  if (title.includes("lager") || path.includes("lager"))
    integrations.push("Warenwirtschaft");
  if (title.includes("personal") || path.includes("personal"))
    integrations.push("HR-System");
  if (title.includes("finanz") || path.includes("finanz"))
    integrations.push("Finanzbuchhaltung");

  return integrations.slice(0, 3);
}

private extractDependencies(node: NodeForAnnotation): string[] {
  const dependencies: string[] = [];

  if (Array.isArray(node.path) && node.path.length > 1) {
    dependencies.push(node.path[node.path.length - 2]);
  }

  if (node.meta_json?.requires && Array.isArray(node.meta_json.requires)) {
    for (const req of node.meta_json.requires) {
      if (typeof req === "string") dependencies.push(req);
    }
  }

  return [...new Set(dependencies)].slice(0, 5);
}

private guessBusinessArea(node: NodeForAnnotation): string {
  const title = (node.title || "").toLowerCase();

  const areaMap: Record<string, string> = {
    umsatz: "Finanzen",
    kosten: "Finanzen",
    finanz: "Finanzen",
    rechnung: "Finanzen",

    kunde: "Vertrieb",
    vertrieb: "Vertrieb",
    auftrag: "Vertrieb",
    angebot: "Vertrieb",

    einkauf: "Einkauf",
    lieferant: "Einkauf",
    bestellung: "Einkauf",

    personal: "HR",
    mitarbeiter: "HR",
    gehalt: "HR",
    lohn: "HR",

    produkt: "Produktion",
    fertigung: "Produktion",
    lager: "Produktion",
    material: "Produktion",

    system: "IT",
    benutzer: "IT",
    rolle: "IT",
    berechtigung: "IT"
  };

  for (const [keyword, area] of Object.entries(areaMap)) {
    if (title.includes(keyword)) return area;
  }

  return "Allgemein";
}

private guessPiiClass(
  node: NodeForAnnotation
): "none" | "low" | "medium" | "high" {
  const title = (node.title || "").toLowerCase();

  if (
    title.includes("personal") ||
    title.includes("gehalt") ||
    title.includes("lohn")
  )
    return "high";

  if (
    title.includes("kunde") ||
    title.includes("adresse") ||
    title.includes("email")
  )
    return "medium";

  if (
    title.includes("benutzer") ||
    title.includes("rolle") ||
    title.includes("abteilung")
  )
    return "low";

  return "none";
}


  // ============ PUBLIC API ============

// ============ VALIDIERUNG (STABIL & KOMPATIBEL) ============

async validateNode(node: NodeForAnnotation): Promise<{
  valid: boolean;
  errors: string[];
  warnings: string[];
  suggestions: string[];
}> {
  const errors: string[] = [];
  const warnings: string[] = [];
  const suggestions: string[] = [];

  // --- Metadaten prüfen ---
  if (!node.meta_json) {
    errors.push("Keine Metadaten vorhanden");
  } else {
    const metaValidation = this.validateMeta(node.meta_json);
    if (!metaValidation.valid) {
      errors.push(...metaValidation.errors);
    }
  }

  // --- Strukturprüfungen ---
  if (!node.schema_json) {
    warnings.push("Kein Schema vorhanden");
  }

  if (typeof node.title !== "string" || node.title.trim().length < 3) {
    warnings.push("Titel sehr kurz");
  }

  if (!Array.isArray(node.path) || node.path.length === 0) {
    warnings.push("Kein Pfad definiert");
  }

  // --- KI-Validierung ---
  try {
    const aiValidation = await this.aiValidateNode(node);

    if (
      aiValidation &&
      Array.isArray(aiValidation.suggestions)
    ) {
      for (const s of aiValidation.suggestions) {
        if (typeof s === "string") suggestions.push(s);
      }
    }
  } catch (error) {
    console.warn("AI validation failed:", error);
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    suggestions
  };
}

// -------------------------------------------------------------

private async aiValidateNode(
  node: NodeForAnnotation
): Promise<{ suggestions: string[] }> {
  const prompt = `
SYSTEM:
Validiere einen ERP-Funktionsknoten. Antworte NUR mit gültigem JSON.

ERWARTETE AUSGABE:
{"suggestions": ["string"]}

KNOTEN:
${JSON.stringify(
    {
      title: node.title,
      kind: node.kind,
      path: node.path,
      meta: node.meta_json
    },
    null,
    2
  )}
  `.trim();

  const raw = await this.callAI(prompt, "validation");
  const parsed = this.safeJsonParse(raw);

  if (!parsed || typeof parsed !== "object") {
    return { suggestions: [] };
  }

  if (!Array.isArray(parsed.suggestions)) {
    return { suggestions: [] };
  }

  return {
    suggestions: parsed.suggestions.filter((x: any) => typeof x === "string")
  };
}

// -------------------------------------------------------------

private safeJsonParse(raw: string): any {
  if (typeof raw !== "string") return {};

  // 1. Direkt versuchen
  try {
    return JSON.parse(raw);
  } catch {}

  // 2. JSON-Objekt im Text suchen
  const objMatch = raw.match(/\{[\s\S]*\}/);
  if (objMatch) {
    try {
      return JSON.parse(objMatch[0]);
    } catch {}
  }

  // 3. JSON-Array suchen
  const arrMatch = raw.match(/\[[\s\S]*\]/);
  if (arrMatch) {
    try {
      return JSON.parse(arrMatch[0]);
    } catch {}
  }

  // 4. Letzte Absicherung: leeres Objekt zurückgeben
  console.warn("safeJsonParse: Konnte keine gültigen JSON-Strukturen finden.");
  return {};
}



async getSystemHealth(): Promise<{
  ai: { status: string; models: number; available: number; reachable: boolean };
  database: { status: string; nodes: number; annotated: number };
  batch: { active: number; completed: number; failed: number };
  performance: { averageResponseTime: number; successRate: number };
}> {
  // ---------- AI STATUS ----------
  let aiReachable = true;
  let aiStatus = "healthy";

  try {
    const baseUrl = process.env.OLLAMA_BASE_URL || "http://localhost:11434";
    const response = await fetch(`${baseUrl}/api/tags`);
    if (!response.ok) {
      aiReachable = false;
      aiStatus = "unreachable";
    }
  } catch {
    aiReachable = false;
    aiStatus = "unreachable";
  }

  const aiInfo = {
    status: aiStatus,
    reachable: aiReachable,
    models: this.availableModels.length,
    available: this.availableModels.filter(m => m.available).length
  };

  // ---------- DATABASE STATUS ----------
  let dbStatus = "healthy";
  let nodeStats = { total: 0, annotationProgress: 0, byStatus: {} as Record<string, number> };

  try {
    nodeStats = await this.databaseTool.getNodeStatistics();
  } catch (err) {
    dbStatus = "unreachable";
  }

  const databaseInfo = {
    status: dbStatus,
    nodes: nodeStats.total ?? 0,
    annotated: Math.round(nodeStats.annotationProgress ?? 0)
  };

  // ---------- BATCH STATUS ----------
  let batchOps: BatchOperation[] = [];
  try {
    batchOps = await this.databaseTool.getBatchOperations(100);
  } catch {
    batchOps = [];
  }

  const batchStats = {
    active: batchOps.filter(op => op.status === "running").length,
    completed: batchOps.filter(op => op.status === "completed").length,
    failed: batchOps.filter(op => op.status === "failed").length
  };

  // ---------- PERFORMANCE ----------
  const totalNodes = nodeStats.total ?? 0;
  const failedNodes = nodeStats.byStatus?.failed ?? 0;

  const performance = {
    averageResponseTime: 0, // kann später gemessen werden
    successRate: totalNodes > 0 ? (totalNodes - failedNodes) / totalNodes : 0
  };

  return {
    ai: aiInfo,
    database: databaseInfo,
    batch: batchStats,
    performance
  };
}
async getStatus() {
  const health = await this.getSystemHealth();

  return {
    provider: this.provider,
    available: true,
    model: this.currentModel ?? null,
    capabilities: this.availableModels.flatMap(m => m.capabilities),
    health,
    errorCorrection: this.errorCorrection
  };
}

async validateConfig() {
  const errors: string[] = [];
  const warnings: string[] = [];

  // -------------------------------
  // 1. OLLAMA Systemprüfung
  // -------------------------------
  try {
    const baseUrl = process.env.OLLAMA_BASE_URL || "http://localhost:11434";
    const response = await fetch(`${baseUrl}/api/tags`);

    if (!response.ok) {
      errors.push("Ollama nicht erreichbar");
    } else {
      const modelsData = await response.json();

      const availableModels = Array.isArray(modelsData.models)
        ? modelsData.models.map((m: any) => m.name)
        : [];

      const configuredModels = this.availableModels.map(m => m.name);

      const missingModels = configuredModels.filter(
        name => !availableModels.includes(name)
      );

      if (missingModels.length > 0) {
        warnings.push(
          `Konfigurierte Modelle fehlen: ${missingModels.join(", ")}`
        );
      }

      if (availableModels.length === 0) {
        warnings.push("Ollama antwortet, aber keine Modelle verfügbar");
      }
    }
  } catch {
    errors.push("Ollama nicht erreichbar");
  }

  // -------------------------------
  // 2. Datenbankprüfung
  // -------------------------------
  try {
    await this.databaseTool.getTotalNodeCount();
  } catch {
    errors.push("Datenbank nicht erreichbar");
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}

private async getNodeMeta(id: string): Promise<any> {
  try {
    const nodes = await this.listCandidates({ search: id, limit: 1 });
    if (!nodes || nodes.length === 0) return {};
    return nodes[0]?.meta_json ?? {};
  } catch {
    return {};
  }
}

}

export default new AiAnnotatorService();