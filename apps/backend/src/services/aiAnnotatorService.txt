// SPDX-License-Identifier: MIT
// apps/backend/src/services/aiAnnotatorService.ts

import db from "./dbService.js";
import { EventEmitter } from "events";
import * as os from "os";



const DEFAULT_AI_PROVIDER = process.env.AI_PROVIDER || "ollama";
const DEFAULT_AI_MODEL = process.env.AI_DEFAULT_MODEL || process.env.OPENAI_MODEL || "qwen3:45";



// ============ ERWEITERTE TYP-DEFINITIONEN ============

export type GeneratedMeta = {
  description: string;
  tags: string[];
  businessArea?: string;
  piiClass?: "none" | "low" | "medium" | "high";
  requires?: string[];
  quality?: { 
    confidence: number; 
    evidence?: string[];
    generatedBy: "ai" | "fallback" | "hybrid";
    modelUsed?: string;
  };
  technical?: {
    complexity: "low" | "medium" | "high";
    dataVolume: "small" | "medium" | "large";
    integrationPoints: string[];
    performanceImpact: "low" | "medium" | "high";
  };
  compliance?: {
    gdprRelevant: boolean;
    retentionPeriod?: number;
    auditRequired: boolean;
  };
};

export type DashboardRule = {
  type: "dashboard-root" | "section" | "metric" | "report" | "form" | "table" | "action" | "config" | "chart" | "kpi" | "alerts";
  widget?: "number" | "chart" | "gauge" | "table" | "form" | "button" | "tabs" | "grid" | "panel" | "progress" | "timeline" | "map";
  dataSource?: string;
  refreshInterval?: number;
  unit?: string;
  permissions?: string[];
  layout?: {
    colSpan?: number;
    rowSpan?: number;
    priority?: number;
    responsive?: boolean;
    breakpoints?: Record<string, any>;
  };
  aggregation?: string;
  timeRange?: string;
  colorScheme?: string;
  thresholds?: {
    warning: number;
    critical: number;
    success: number;
  };
  alerts?: AlertRule[];
};

export type AlertRule = {
  condition: string;
  severity: "info" | "warning" | "error" | "critical";
  message: string;
  actions: string[];
};

export type FormSpec = {
  title: string;
  description?: string;
  fields: FormField[];
  layout: "vertical" | "horizontal" | "wizard" | "tabs" | "accordion";
  validation?: ValidationRule[];
  actions: string[];
  sections?: FormSection[];
  conditionalLogic?: ConditionalLogic[];
};

export type FormSection = {
  title: string;
  description?: string;
  fields: string[];
  conditional?: {
    field: string;
    value: any;
  };
};

export type FormField = {
  name: string;
  type: "text" | "number" | "date" | "select" | "checkbox" | "textarea" | "email" | "phone" | "currency" | "percentage" | "file" | "password";
  label: string;
  required?: boolean;
  options?: string[];
  placeholder?: string;
  validation?: FieldValidation;
  helpText?: string;
  defaultValue?: any;
  conditional?: ConditionalLogic;
};

export type ConditionalLogic = {
  field: string;
  operator: "equals" | "notEquals" | "contains" | "greaterThan" | "lessThan";
  value: any;
  action: "show" | "hide" | "enable" | "disable";
};

export type ValidationRule = {
  field: string;
  type: "required" | "min" | "max" | "pattern" | "custom" | "email" | "url" | "phone";
  value?: any;
  message: string;
};

export type FieldValidation = {
  min?: number;
  max?: number;
  pattern?: string;
  custom?: string;
};

export type NodeForAnnotation = {
  id: string;
  title: string;
  kind: string;
  path: string[];
  meta_json?: any | null;
  schema_json?: any | null;
  aa_json?: any | null;
  source_file?: string | null;
  rule?: DashboardRule;
  created_at?: string;
  updated_at?: string;
  last_annotated?: string;
  annotation_status?: "pending" | "processing" | "completed" | "failed" | "needs_review";
};

export type BatchOperation = {
  id?: string;
  operation: "generate_meta" | "generate_forms" | "enhance_schema" | "classify_pii" | "generate_rule" | "full_annotation" | "validate_nodes";
  filters: any;
  options?: BatchOptions;
  status?: "pending" | "running" | "completed" | "failed" | "cancelled";
  progress?: number;
  created_at?: string;
  started_at?: string;
  completed_at?: string;
};

export type BatchOptions = {
  retryFailed?: boolean;
  maxRetries?: number;
  chunkSize?: number;
  parallelRequests?: number;
  modelPreference?: "auto" | "fast" | "accurate" | "balanced";
  fallbackStrategy?: "aggressive" | "conservative" | "hybrid";
  validationRules?: ValidationConfig;
};

export type ValidationConfig = {
  minDescriptionLength?: number;
  maxTags?: number;
  requiredFields?: string[];
  businessAreaWhitelist?: string[];
};

export type BatchResult = {
  id: string;
  total: number;
  processed: number;
  successful: number;
  failed: number;
  errors: string[];
  results: Array<{
    id: string;
    success: boolean;
    result?: any;
    error?: string;
    retries?: number;
    duration?: number;
  }>;
  summary?: {
    averageConfidence: number;
    businessAreas: Record<string, number>;
    piiDistribution: Record<string, number>;
    qualityScore: number;
  };
};

export type AIProvider =  | "ollama" | "anthropic" | "local" | "hybrid" | "openai" | "none";

export type ModelConfig = {
  name: string;
  provider: AIProvider;
  capabilities: string[];
  maxTokens: number;
  contextWindow: number;
  costPerToken?: number;
  speed: "slow" | "medium" | "fast";
  accuracy: "low" | "medium" | "high";
  available: boolean;
};

export type ErrorCorrectionConfig = {
  enabled: boolean;
  maxRetries: number;
  retryDelay: number;
  fallbackModels: string[];
  validationRules: string[];
  autoCorrect: boolean;
};

// ============ FEHLENDE TYP-DEFINITIONEN ============

export type GeneratedRule = {
  id: string;
  rule: DashboardRule;
  quality: {
    confidence: number;
    evidence: string[];
    generatedBy: "ai" | "fallback" | "hybrid";
    modelUsed?: string;
  };
};

export type GeneratedFormSpec = {
  id: string;
  form: FormSpec;
  quality: {
    confidence: number;
    evidence: string[];
    generatedBy: "ai" | "fallback" | "hybrid";
    modelUsed?: string;
  };
};

export type PiiResult = {
  id: string;
  piiClass: "none" | "low" | "medium" | "high";
  reason: string;
  confidence: number;
  generatedBy: "ai" | "fallback" | "hybrid";
};

// ============ DATABASE TOOL ============

export class DatabaseTool {
  private static instance: DatabaseTool;

  static getInstance(): DatabaseTool {
    if (!DatabaseTool.instance) {
      DatabaseTool.instance = new DatabaseTool();
    }
    return DatabaseTool.instance;
  }

  async getNodeStatistics(): Promise<{
    total: number;
    byKind: Record<string, number>;
    byStatus: Record<string, number>;
    annotationProgress: number;
    averageConfidence: number;
  }> {
    try {
      const nodes = await db.all(`
        SELECT kind, annotation_status, meta_json
        FROM functions_nodes
        WHERE meta_json IS NOT NULL
      `) as Array<{ kind: string; annotation_status?: string | null; meta_json?: any }>;

      const stats = {
        total: nodes.length,
        byKind: {} as Record<string, number>,
        byStatus: {} as Record<string, number>,
        annotationProgress: 0,
        averageConfidence: 0
      };

      let totalConfidence = 0;
      let nodesWithConfidence = 0;

      nodes.forEach((node) => {
        stats.byKind[node.kind] = (stats.byKind[node.kind] || 0) + 1;
        
        const status = node.annotation_status || 'unknown';
        stats.byStatus[status] = (stats.byStatus[status] || 0) + 1;
        
        if (node.meta_json && node.meta_json.quality) {
          totalConfidence += node.meta_json.quality.confidence || 0;
          nodesWithConfidence++;
        }
      });

      stats.annotationProgress = (nodes.length / (await this.getTotalNodeCount())) * 100;
      stats.averageConfidence = nodesWithConfidence > 0 ? totalConfidence / nodesWithConfidence : 0;

      return stats;
    } catch (error) {
      console.error('Error getting node statistics:', error);
      throw error;
    }
  }

  async getTotalNodeCount(): Promise<number> {
    const result = await db.get('SELECT COUNT(*) as count FROM functions_nodes') as { count?: number } | undefined;
    return result?.count ?? 0;
  }

  async getBatchOperations(limit: number = 50): Promise<BatchOperation[]> {
    try {
      const rows = await db.all(`
        SELECT * FROM batch_operations 
        ORDER BY created_at DESC 
        LIMIT ?
      `, [limit]) as Array<{
        id: string;
        operation: string;
        filters: string;
        options?: string | null;
        status?: string;
        progress?: number;
        created_at?: string;
        started_at?: string;
        completed_at?: string;
      }>;
      
      return rows.map((row: any) => ({
        ...row,
        filters: row.filters ? JSON.parse(row.filters) : {},
        options: row.options ? JSON.parse(row.options) : {}
      }));
    } catch (error) {
      console.error('Error getting batch operations:', error);
      return [];
    }
  }

  async saveBatchOperation(operation: BatchOperation): Promise<string> {
    const id = operation.id || `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    await db.run(`
      INSERT OR REPLACE INTO batch_operations (id, operation, filters, options, status, progress, created_at)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `, [
      id,
      operation.operation,
      JSON.stringify(operation.filters),
      JSON.stringify(operation.options || {}),
      operation.status || 'pending',
      operation.progress || 0,
      operation.created_at || new Date().toISOString()
    ]);
    
    return id;
  }

  async updateBatchProgress(id: string, progress: number, status?: string): Promise<void> {
    const updates: string[] = ['progress = ?'];
    const params: any[] = [progress];

    if (status) {
      updates.push('status = ?');
      params.push(status);
    }

    if (status === 'completed' || status === 'failed') {
      updates.push('completed_at = ?');
      params.push(new Date().toISOString());
    }

    params.push(id);

    await db.run(`
      UPDATE batch_operations 
      SET ${updates.join(', ')}
      WHERE id = ?
    `, params);
  }

  async cleanupOldBatches(daysToKeep: number = 30): Promise<void> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

    await db.run(`
      DELETE FROM batch_operations 
      WHERE created_at < ?
    `, [cutoffDate.toISOString()]);
  }
}

// ============ ERWEITERTER HAUPTSERVICE ============

export class AiAnnotatorService extends EventEmitter {
  private provider: AIProvider;
  private currentModel: string;
  private availableModels: ModelConfig[];
  private isLargeModel: boolean;
  private errorCorrection: ErrorCorrectionConfig;
  private databaseTool: DatabaseTool;
  private activeBatches: Map<string, BatchOperation> = new Map();

  constructor() {
    super();
    this.provider = this.detectProvider();
    this.currentModel = this.getDefaultModel();
    this.availableModels = this.initializeModels();
    this.isLargeModel = this.detectModelCapabilities();
    this.errorCorrection = this.initializeErrorCorrection();
    this.databaseTool = DatabaseTool.getInstance();
    
    this.setupEventHandlers();
  }

  

  private setupEventHandlers() {
    this.on('batch_progress', (batchId: string, progress: number) => {
      this.databaseTool.updateBatchProgress(batchId, progress);
    });

    this.on('batch_complete', (batchId: string) => {
      this.databaseTool.updateBatchProgress(batchId, 100, 'completed');
      this.activeBatches.delete(batchId);
    });

    this.on('batch_error', (batchId: string, error: Error) => {
      this.databaseTool.updateBatchProgress(batchId, 0, 'failed');
      this.activeBatches.delete(batchId);
    });
  }

  private detectProvider(): AIProvider {
    const envProvider = (process.env.AI_PROVIDER || "").toLowerCase();
    
    if (envProvider === "openai" && process.env.OPENAI_API_KEY) {
      return "openai";
    }
    if (envProvider === "ollama") {
      return "ollama";
    }
    if (envProvider === "anthropic" && process.env.ANTHROPIC_API_KEY) {
      return "anthropic";
    }
    if (envProvider === "local" && process.env.LOCAL_MODEL_PATH) {
      return "local";
    }
    if (envProvider === "hybrid") {
      return "hybrid";
    }
    return "none";
  }

  private initializeModels(): ModelConfig[] {
    const models: ModelConfig[] = [
      {
        name: "gpt-4o",
        provider: "openai",
        capabilities: ["meta", "rules", "forms", "schema", "pii", "complex"],
        maxTokens: 128000,
        contextWindow: 128000,
        speed: "fast",
        accuracy: "high",
        available: !!process.env.OPENAI_API_KEY
      },
      {
        name: "gpt-4o-mini",
        provider: "openai",
        capabilities: ["meta", "rules", "forms", "schema", "pii"],
        maxTokens: 128000,
        contextWindow: 128000,
        speed: "fast",
        accuracy: "medium",
        available: !!process.env.OPENAI_API_KEY
      },
      {
        name: "claude-3-5-sonnet",
        provider: "anthropic",
        capabilities: ["meta", "rules", "forms", "schema", "pii", "complex"],
        maxTokens: 200000,
        contextWindow: 200000,
        speed: "medium",
        accuracy: "high",
        available: !!process.env.ANTHROPIC_API_KEY
      },
      {
        name: "qwen3:4b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms"],
        maxTokens: 32768,
        contextWindow: 32768,
        speed: "medium",
        accuracy: "medium",
        available: true
      },
            {
        name: "qwen3:b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms"],
        maxTokens: 32768,
        contextWindow: 32768,
        speed: "medium",
        accuracy: "medium",
        available: true
      },
      {
        name: "llama3.1:8b",
        provider: "ollama",
        capabilities: ["meta", "rules", "forms"],
        maxTokens: 8192,
        contextWindow: 8192,
        speed: "medium",
        accuracy: "medium",
        available: true
      },
      {
        name: "fallback",
        provider: "none",
        capabilities: ["meta", "rules", "forms"],
        maxTokens: 1000,
        contextWindow: 1000,
        speed: "fast",
        accuracy: "low",
        available: true
      }
    ];

    return models.filter(model => model.available);
  }

  private getDefaultModel(): string {
    switch (this.provider) {
      case "openai":
        return process.env.OPENAI_MODEL || "gpt-4o-mini";
      case "ollama":
        return process.env.OLLAMA_MODEL || "qwen3:4b";
      case "anthropic":
        return process.env.ANTHROPIC_MODEL || "claude-3-5-sonnet";
      case "local":
        return process.env.LOCAL_MODEL_NAME || "local-llama";
      default:
        return "fallback";
    }
  }

  private detectModelCapabilities(): boolean {
    const model = this.availableModels.find(m => m.name === this.currentModel);
    return model ? model.capabilities.includes("complex") : false;
  }

  private initializeErrorCorrection(): ErrorCorrectionConfig {
    return {
      enabled: process.env.ERROR_CORRECTION !== "false",
      maxRetries: parseInt(process.env.MAX_RETRIES || "3"),
      retryDelay: parseInt(process.env.RETRY_DELAY_MS || "1000"),

      // Fallback-Reihenfolge: zuerst Qwen, dann reines Fallback
      fallbackModels: (process.env.FALLBACK_MODELS || "qwen3:4b,fallback").split(","),

      validationRules: (process.env.VALIDATION_RULES || "json,required_fields,business_area").split(","),
      autoCorrect: process.env.AUTO_CORRECT === "true"
    };
}


  // ============ KERN-FUNKTIONEN ============

  async listCandidates(opts: {
    kinds?: string[];
    missingOnly?: boolean;
    limit?: number;
    offset?: number;
    search?: string;
    status?: string[];
    businessArea?: string[];
    complexity?: string[];
  }): Promise<NodeForAnnotation[]> {
    const limit = Math.max(1, Math.min(10_000, opts.limit ?? 500));
    const offset = Math.max(0, opts.offset ?? 0);

    const params: any[] = [];
    let sql = `
      SELECT id, title, kind, path_json as path,
             meta_json, schema_json, aa_json, source_file,
             created_at, updated_at, last_annotated, annotation_status
      FROM functions_nodes
      WHERE 1=1
    `;
    
    if (opts.missingOnly) {
      sql += ` AND (meta_json IS NULL OR meta_json = '' OR json_type(meta_json) = 'null')`;
    }
    if (opts.kinds?.length) {
      sql += ` AND kind IN (${opts.kinds.map(() => "?").join(",")})`;
      params.push(...opts.kinds);
    }
    if (opts.search) {
      sql += ` AND (title LIKE ? OR id LIKE ? OR path_json LIKE ?)`;
      params.push(`%${opts.search}%`, `%${opts.search}%`, `%${opts.search}%`);
    }
    if (opts.status?.length) {
      sql += ` AND annotation_status IN (${opts.status.map(() => "?").join(",")})`;
      params.push(...opts.status);
    }
    
    sql += ` ORDER BY created_at DESC LIMIT ? OFFSET ?`;
    params.push(limit, offset);

    try {
      const rows = await db.all(sql, params) as any[];
      return rows.map((r: any) => ({
        id: r.id,
        title: r.title,
        kind: r.kind,
        path: typeof r.path === "string" ? JSON.parse(r.path) : r.path,
        meta_json: r.meta_json ?? null,
        schema_json: r.schema_json ?? null,
        aa_json: r.aa_json ?? null,
        source_file: r.source_file ?? null,
        created_at: r.created_at,
        updated_at: r.updated_at,
        last_annotated: r.last_annotated,
        annotation_status: r.annotation_status || 'pending'
      }));
    } catch (error) {
      console.error("Database error in listCandidates:", error);
      throw error;
    }
  }

  async saveMeta(id: string, meta: GeneratedMeta): Promise<void> {
    try {
      await db.run(`
        UPDATE functions_nodes 
        SET meta_json = ?, updated_at = ?, last_annotated = ?, annotation_status = ?
        WHERE id = ?
      `, [JSON.stringify(meta), new Date().toISOString(), new Date().toISOString(), 'completed', id]);
    } catch (error) {
      console.error(`Failed to save meta for ${id}:`, error);
      throw error;
    }
  }

  async saveRule(id: string, rule: DashboardRule): Promise<void> {
    try {
      const currentMeta = await this.getNodeMeta(id);
      const updatedMeta = {
        ...currentMeta,
        rule,
        updated_at: new Date().toISOString(),
        last_annotated: new Date().toISOString()
      };
      await this.saveMeta(id, updatedMeta);
    } catch (error) {
      console.error(`Failed to save rule for ${id}:`, error);
      throw error;
    }
  }

  async saveFormSpec(id: string, formSpec: FormSpec): Promise<void> {
    try {
      const currentMeta = await this.getNodeMeta(id);
      const updatedMeta = {
        ...currentMeta,
        formSpec,
        updated_at: new Date().toISOString(),
        last_annotated: new Date().toISOString()
      };
      await this.saveMeta(id, updatedMeta);
    } catch (error) {
      console.error(`Failed to save form spec for ${id}:`, error);
      throw error;
    }
  }

  // ============ KI-GENERIERUNG ============

  async generateMeta(node: NodeForAnnotation, retryCount = 0): Promise<GeneratedMeta> {
    if (this.provider === "none" || retryCount >= this.errorCorrection.maxRetries) {
      return this.generateEnhancedFallbackMeta(node);
    }

    try {
      const prompt = this.isLargeModel
        ? this.buildEnhancedMetaPrompt(node)
        : this.buildSimpleMetaPrompt(node);

      const raw = await this.callAI(prompt, "meta");
      const meta = this.parseMetaJson(raw, node);

      const validation = this.validateMeta(meta);
      if (!validation.valid && this.errorCorrection.autoCorrect) {
        console.warn(`Meta validation failed for ${node.id}, attempting correction:`, validation.errors);
        return await this.correctMetaGeneration(node, meta, validation.errors, retryCount);
      }

      return {
        ...meta,
        quality: {
          confidence: meta.quality?.confidence ?? 0.5,
          evidence: meta.quality?.evidence ?? ["Automatisch generiert"],
          generatedBy: "ai",
          modelUsed: this.currentModel,
        },
      };

    } catch (error) {
      console.warn(`AI generation failed for ${node.id} (attempt ${retryCount + 1}):`, error);

      if (this.errorCorrection.enabled && retryCount < this.errorCorrection.maxRetries) {
        await this.delay(this.errorCorrection.retryDelay * (retryCount + 1));
        return this.generateMeta(node, retryCount + 1);
      }

      return this.generateEnhancedFallbackMeta(node);
    }
  }

  async generateRule(node: NodeForAnnotation, retryCount = 0): Promise<DashboardRule> {
    if (this.provider === "none" || retryCount >= this.errorCorrection.maxRetries) {
      return this.generateFallbackRule(node);
    }

    try {
      const prompt = this.buildRulePrompt(node);
      const raw = await this.callAI(prompt, "rule");
      return this.parseRuleJson(raw);
    } catch (error) {
      console.warn(`Rule generation failed for ${node.id} (attempt ${retryCount + 1}):`, error);
      
      if (this.errorCorrection.enabled && retryCount < this.errorCorrection.maxRetries) {
        await this.delay(this.errorCorrection.retryDelay * (retryCount + 1));
        return this.generateRule(node, retryCount + 1);
      }
      
      return this.generateFallbackRule(node);
    }
  }

  async generateFormSpec(node: NodeForAnnotation, retryCount = 0): Promise<FormSpec> {
    if (this.provider === "none" || retryCount >= this.errorCorrection.maxRetries) {
      return this.generateFallbackForm(node);
    }

    try {
      const prompt = this.buildFormPrompt(node);
      const raw = await this.callAI(prompt, "form");
      return this.parseFormJson(raw);
    } catch (error) {
      console.warn(`Form generation failed for ${node.id} (attempt ${retryCount + 1}):`, error);
      
      if (this.errorCorrection.enabled && retryCount < this.errorCorrection.maxRetries) {
        await this.delay(this.errorCorrection.retryDelay * (retryCount + 1));
        return this.generateFormSpec(node, retryCount + 1);
      }
      
      return this.generateFallbackForm(node);
    }
  }

  async enhanceSchema(node: NodeForAnnotation): Promise<any> {
    if (this.provider === "none") {
      return node.schema_json || {};
    }

    try {
      const prompt = this.buildSchemaEnhancementPrompt(node);
      const raw = await this.callAI(prompt, "schema");
      return JSON.parse(raw);
    } catch (error) {
      console.warn(`Schema enhancement failed for ${node.id}:`, error);
      return node.schema_json || {};
    }
  }

  async classifyPii(nodes: NodeForAnnotation[]): Promise<PiiResult[]> {
    if (this.provider === "none") {
      return nodes.map(node => ({
        id: node.id,
        piiClass: this.guessPiiClass(node),
        reason: "Fallback-Klassifizierung",
        confidence: 0.3,
        generatedBy: "fallback"
      }));
    }

    try {
      const prompt = this.buildPiiClassificationPrompt(nodes);
      const raw = await this.callAI(prompt, "pii");
      return this.parsePiiClassification(raw, nodes);
    } catch (error) {
      console.warn(`PII classification failed:`, error);
      return nodes.map(node => ({
        id: node.id,
        piiClass: this.guessPiiClass(node),
        reason: "Fallback nach Fehler",
        confidence: 0.3,
        generatedBy: "fallback"
      }));
    }
  }

  // ============ AI-CALLS ============

  private async callAI(prompt: string, operation: string): Promise<string> {
    const model = this.selectModelForOperation(operation);
    
    try {
      switch (model.provider) {
        case "openai":
          return await this.callOpenAI(prompt, model.name);
        case "ollama":
          return await this.callOllama(prompt, model.name);
        case "anthropic":
          return await this.callAnthropic(prompt, model.name);
        case "local":
          return await this.callLocal(prompt);
        default:
          throw new Error(`Unsupported provider: ${model.provider}`);
      }
    } catch (error) {
      console.warn(`AI call failed with model ${model.name}, trying fallback`);
      return await this.fallbackAI(prompt, operation, error);
    }
  }

  private async callOpenAI(prompt: string, model: string): Promise<string> {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error("OPENAI_API_KEY ist nicht gesetzt");
    }

    const url = process.env.OPENAI_API_URL || "https://api.openai.com/v1/chat/completions";

    const body = {
      model,
      messages: [
        { role: "system", content: "Du bist ein präziser Assistent, der immer gültiges JSON zurückgibt." },
        { role: "user", content: prompt }
      ],
      temperature: 0.1,
      max_tokens: 4000,
    };

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`OpenAI HTTP ${response.status}: ${text}`);
    }

    const data = await response.json();
    return data.choices?.[0]?.message?.content ?? "{}";
  }

  private async callOllama(prompt: string, model: string): Promise<string> {
    const baseUrl = process.env.OLLAMA_BASE_URL || "http://localhost:11434";
    
    try {
  const modelsResponse = await fetch(`${baseUrl}/api/tags`);
  if (!modelsResponse.ok) {
    throw new Error(`Ollama /api/tags HTTP ${modelsResponse.status}`);
  }

  const modelsData = await modelsResponse.json();
  const availableModels = Array.isArray(modelsData.models)
    ? modelsData.models.map((m: any) => m.name)
    : [];

  if (!availableModels.includes(model)) {
    console.warn(`[ollama] Modell "${model}" nicht gefunden – versuche Download...`);
    const pullResp = await fetch(`${baseUrl}/api/pull`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ name: model, stream: false }),
    });

    if (!pullResp.ok) {
      const errText = await pullResp.text().catch(() => "");
      throw new Error(`Ollama Pull-Fehler ${pullResp.status}: ${errText}`);
    }

    const pullResult = await pullResp.json().catch(() => ({}));
    if (pullResult.error) {
      throw new Error(`Ollama Pull meldet Fehler: ${pullResult.error}`);
    }

    console.log(`[ollama] Modell "${model}" erfolgreich überprüft oder geladen.`);
  }
} catch (error: any) {
  console.warn(`[ollama] Modellprüfung oder Download fehlgeschlagen: ${error.message || error}`);
}

    
    const resp = await fetch(`${baseUrl}/api/generate`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        model: model,
        prompt: prompt,
        stream: false,
        options: {
          temperature: 0.1,
          top_p: 0.9,
          num_predict: 4000
        }
      }),
    });

    if (!resp.ok) {
      const text = await resp.text();
      throw new Error(`Ollama HTTP ${resp.status}: ${text}`);
    }

    const data = await resp.json();
    return data.response || "{}";
  }

  private async callAnthropic(prompt: string, model: string): Promise<string> {
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) throw new Error("ANTHROPIC_API_KEY nicht konfiguriert");

    const resp = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: model,
        max_tokens: 4000,
        temperature: 0.1,
        system: "Du bist ein präziser Assistent für ERP-Funktionskataloge. Antworte immer mit gültigem JSON.",
        messages: [{ role: "user", content: prompt }]
      })
    });

    if (!resp.ok) {
      const text = await resp.text();
      throw new Error(`Anthropic HTTP ${resp.status}: ${text}`);
    }

    const data = await resp.json();
    return data.content[0].text;
  }

  private async callLocal(prompt: string): Promise<string> {
    console.log("Local AI call (simulated):", prompt.substring(0, 100) + "...");
    
    if (prompt.includes("METADATEN-GENERIERUNG")) {
      return JSON.stringify({
        description: `Lokal generierte Beschreibung für ERP-Funktion`,
        tags: ["lokal", "generiert"],
        businessArea: "Allgemein",
        piiClass: "none",
        quality: { confidence: 0.5 }
      });
    }
    
    return "{}";
  }

  private async fallbackAI(prompt: string, operation: string, originalError: any): Promise<string> {
    console.warn(`Using fallback for ${operation} due to:`, originalError);
    
    const fallbackIndex = this.errorCorrection.fallbackModels.indexOf(this.currentModel);
    if (fallbackIndex < this.errorCorrection.fallbackModels.length - 1) {
      const nextModel = this.errorCorrection.fallbackModels[fallbackIndex + 1];
      console.log(`Trying fallback model: ${nextModel}`);
      this.currentModel = nextModel;
      return this.callAI(prompt, operation);
    }

    return this.generateLocalFallback(operation);
  }

  // ============ PROMPT-BUILDING ============

  private buildEnhancedMetaPrompt(node: NodeForAnnotation): string {
    return `
# ERP-Funktionsknoten Metadaten-Generierung

## AUFGABE:
Generiere umfassende Metadaten für einen ERP-Funktionsknoten.

## ANTWORTFORMAT:
Antworte ausschließlich mit gültigem JSON:

{
  "description": "string (2-4 Sätze, fachlich präzise)",
  "tags": ["string[] (5-10 relevante Stichwörter)"],
  "businessArea": "Finanzen|Vertrieb|Einkauf|HR|Produktion|IT|Logistik|Marketing|Allgemein",
  "piiClass": "none|low|medium|high",
  "requires": ["string[] (abhängige Funktionen)"],
  "quality": {
    "confidence": number (0-1),
    "evidence": ["string[] (Begründung für die Bewertung)"]
  },
  "technical": {
    "complexity": "low|medium|high",
    "dataVolume": "small|medium|large", 
    "integrationPoints": ["string[]"],
    "performanceImpact": "low|medium|high"
  },
  "compliance": {
    "gdprRelevant": boolean,
    "retentionPeriod": number (in Tagen, optional),
    "auditRequired": boolean
  }
}

## KNOTENDATEN:
${JSON.stringify({
  id: node.id,
  title: node.title,
  kind: node.kind,
  path: node.path,
  hasSchema: !!node.schema_json,
  hasWorkflow: !!node.aa_json,
  schemaFields: node.schema_json ? Object.keys(node.schema_json).slice(0, 10) : [],
  workflowSteps: node.aa_json ? Object.keys(node.aa_json).slice(0, 5) : []
}, null, 2)}
    `;
  }

  private buildSimpleMetaPrompt(node: NodeForAnnotation): string {
    return `
# METADATEN-GENERIERUNG (VEREINFACHT)

Erstelle eine kompakte JSON-Beschreibung der ERP-Funktion.

Antworte ausschließlich mit **gültigem JSON**:

{
  "description": "string",
  "tags": ["string"],
  "businessArea": "Finanzen|Vertrieb|Einkauf|HR|Produktion|IT|Logistik|Marketing|Allgemein",
  "piiClass": "none|low|medium|high",
  "quality": { "confidence": number }
}

Kontext:
- Titel: ${node.title}
- Typ: ${node.kind}
- Pfad: ${node.path.join(" → ")}
    `;
  }

  private buildRulePrompt(node: NodeForAnnotation): string {
    return `
Erzeuge eine Dashboard-Regel für einen ERP-Funktionsknoten.
Antworte ausschließlich mit JSON:

{
  "type": "dashboard-root|section|metric|report|form|table|action|config|chart|kpi|alerts",
  "widget": "number|chart|gauge|table|form|button|tabs|grid|panel|progress|timeline|map",
  "dataSource": "string (optional)",
  "refreshInterval": number (optional),
  "unit": "string (optional)",
  "permissions": ["string[] (optional)"],
  "layout": {
    "colSpan": number,
    "rowSpan": number,
    "priority": number
  }
}

Knotendaten:
${JSON.stringify({
  title: node.title,
  path: node.path,
  kind: node.kind,
  tags: node.meta_json?.tags || []
}, null, 2)}
    `;
  }

  private buildFormPrompt(node: NodeForAnnotation): string {
    return `
Erzeuge eine Formular-Spezifikation für eine ERP-Funktion.
Antworte ausschließlich mit JSON:

{
  "title": "string",
  "fields": [
    {
      "name": "string",
      "type": "text|number|date|select|checkbox|textarea",
      "label": "string",
      "required": boolean,
      "options": ["string[] (optional)"],
      "placeholder": "string (optional)"
    }
  ],
  "layout": "vertical|horizontal|wizard",
  "validation": [
    {
      "field": "string",
      "type": "required|min|max|pattern",
      "message": "string"
    }
  ],
  "actions": ["string[]"]
}

Kontext: ${node.title} - ${JSON.stringify(node.path)}
    `;
  }

  private buildSchemaEnhancementPrompt(node: NodeForAnnotation): string {
    return `
Verbessere das Daten-Schema für die ERP-Funktion "${node.title}".
    
Aktuelles Schema:
${JSON.stringify(node.schema_json || {}, null, 2)}

Antworte mit dem verbesserten Schema im JSON-Format.
    `;
  }

  private buildPiiClassificationPrompt(nodes: NodeForAnnotation[]): string {
    const nodeData = nodes.map(n => ({
      id: n.id,
      title: n.title,
      kind: n.kind,
      path: n.path
    }));

    return `
Klassifiziere personenbezogene Informationen (PII) für folgende ERP-Funktionen.
Antworte ausschließlich mit JSON-Array:

[
  {
    "id": "string",
    "piiClass": "none|low|medium|high", 
    "reason": "string",
    "confidence": number
  }
]

Knoten zur Analyse:
${JSON.stringify(nodeData, null, 2)}
    `;
  }

  private buildCorrectionPrompt(node: NodeForAnnotation, invalidMeta: GeneratedMeta, errors: string[]): string {
    return `
# METADATEN-KORREKTUR

## AUFGABE:
Korrigiere die fehlerhaften Metadaten basierend auf den Validierungsfehlern.

## FEHLER:
${errors.map(error => `- ${error}`).join('\n')}

## ORIGINALE (FEHLERHAFTE) METADATEN:
${JSON.stringify(invalidMeta, null, 2)}

## KNOTEN-INFORMATION:
${JSON.stringify({
  title: node.title,
  kind: node.kind, 
  path: node.path
}, null, 2)}

## KORRIGIERTE ANTWORT:
Gib nur das korrigierte JSON zurück.
    `;
  }

  // ============ PARSING ============

  private parseMetaJson(raw: string, node: NodeForAnnotation): GeneratedMeta {
    let parsed: any = {};

    try {
      parsed = JSON.parse(raw);
    } catch {
      const match = raw.match(/\{[\s\S]*\}/);
      if (match) {
        try {
          parsed = JSON.parse(match[0]);
        } catch (err) {
          console.warn("parseMetaJson: JSON parsing failed:", err);
          parsed = {};
        }
      }
    }

    return {
      description: parsed.description || `Automatisch generierte Beschreibung für ${node.title}`,
      tags: Array.isArray(parsed.tags) && parsed.tags.length > 0 ? parsed.tags : [node.kind, ...node.title.split(" ").slice(0, 3)],
      businessArea: parsed.businessArea || this.guessBusinessArea(node),
      piiClass: parsed.piiClass || this.guessPiiClass(node),
      requires: parsed.requires || [],
      quality: {
        confidence: typeof parsed.quality?.confidence === "number" ? parsed.quality.confidence : 0.5,
        evidence: parsed.quality?.evidence || ["Automatisch generiert"],
        generatedBy: "ai",
        modelUsed: this.currentModel,
      },
      technical: parsed.technical || this.analyzeTechnicalComplexity(node),
      compliance: parsed.compliance || { gdprRelevant: false, auditRequired: false },
    };
  }

  private parseRuleJson(raw: string): DashboardRule {
    try {
      const obj = JSON.parse(raw);
      const validTypes = ["dashboard-root", "section", "metric", "report", "form", "table", "action", "config", "chart", "kpi", "alerts"];
      const validWidgets = ["number", "chart", "gauge", "table", "form", "button", "tabs", "grid", "panel", "progress", "timeline", "map"];
      
      return {
        type: validTypes.includes(obj.type) ? obj.type : "section",
        widget: validWidgets.includes(obj.widget) ? obj.widget : undefined,
        dataSource: obj.dataSource,
        refreshInterval: obj.refreshInterval,
        unit: obj.unit,
        permissions: Array.isArray(obj.permissions) ? obj.permissions : [],
        layout: obj.layout || { colSpan: 1, rowSpan: 1, priority: 1 },
        aggregation: obj.aggregation,
        timeRange: obj.timeRange,
        colorScheme: obj.colorScheme
      };
    } catch {
      return this.generateFallbackRule({} as NodeForAnnotation);
    }
  }

  private parseFormJson(raw: string): FormSpec {
    try {
      const obj = JSON.parse(raw);
      return {
        title: obj.title || "Formular",
        fields: Array.isArray(obj.fields) ? obj.fields : [],
        layout: obj.layout || "vertical",
        validation: obj.validation || [],
        actions: obj.actions || ["speichern", "abbrechen"]
      };
    } catch {
      return this.generateFallbackForm({} as NodeForAnnotation);
    }
  }

  private parsePiiClassification(raw: string, nodes: NodeForAnnotation[]): PiiResult[] {
    try {
      const obj = JSON.parse(raw);
      if (!Array.isArray(obj)) {
        throw new Error("Expected array response");
      }

      return obj.map((item: any) => ({
        id: item.id,
        piiClass: ["none", "low", "medium", "high"].includes(item.piiClass) ? item.piiClass : "none",
        reason: item.reason || "Automatisch klassifiziert",
        confidence: Math.min(1, Math.max(0, Number(item.confidence ?? 0.5))),
        generatedBy: "ai"
      }));
    } catch (error) {
      console.warn("Failed to parse PII classification, using fallback");
      return nodes.map(node => ({
        id: node.id,
        piiClass: this.guessPiiClass(node),
        reason: "Fallback nach Parse-Fehler",
        confidence: 0.3,
        generatedBy: "fallback"
      }));
    }
  }

  // ============ VALIDATION ============

  private validateMeta(meta: GeneratedMeta): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!meta.description || meta.description.length < 10) {
      errors.push("Description too short");
    }

    if (!meta.tags || meta.tags.length === 0) {
      errors.push("No tags provided");
    }

    const validBusinessAreas = ["Finanzen", "Vertrieb", "Einkauf", "HR", "Produktion", "IT", "Logistik", "Marketing", "Allgemein"];
    if (meta.businessArea && !validBusinessAreas.includes(meta.businessArea)) {
      errors.push(`Invalid business area: ${meta.businessArea}`);
    }

    return { valid: errors.length === 0, errors };
  }

  // ============ BATCH OPERATIONS ============

  async executeBatchOperation(operation: BatchOperation): Promise<BatchResult> {
    const batchId = await this.databaseTool.saveBatchOperation({
      ...operation,
      status: 'running',
      started_at: new Date().toISOString(),
      progress: 0
    });

    this.activeBatches.set(batchId, operation);

    try {
      const nodes = await this.listCandidates(operation.filters);
      const result: BatchResult = {
        id: batchId,
        total: nodes.length,
        processed: 0,
        successful: 0,
        failed: 0,
        errors: [],
        results: []
      };

      const chunkSize = operation.options?.chunkSize || 10;

      for (let i = 0; i < nodes.length; i += chunkSize) {
        const chunk = nodes.slice(i, i + chunkSize);
        
        const chunkPromises = chunk.map(async (node, index) => {
          await this.delay(index * 100);
          return this.processBatchNode(node, operation, batchId);
        });

        const chunkResults = await Promise.allSettled(chunkPromises);
        
        chunkResults.forEach((settledResult, chunkIndex) => {
          const node = chunk[chunkIndex];
          if (settledResult.status === 'fulfilled') {
            const nodeResult = settledResult.value;
            result.results.push(nodeResult);
            if (nodeResult.success) {
              result.successful++;
            } else {
              result.failed++;
              result.errors.push(`${node.id}: ${nodeResult.error}`);
            }
          } else {
            result.results.push({
              id: node.id,
              success: false,
              error: settledResult.reason.message,
              retries: 0
            });
            result.failed++;
            result.errors.push(`${node.id}: ${settledResult.reason.message}`);
          }
          result.processed++;
        });

        const progress = Math.round((result.processed / result.total) * 100);
        this.emit('batch_progress', batchId, progress);
        
        await this.delay(500);
      }

      result.summary = this.calculateBatchSummary(result);
      this.emit('batch_complete', batchId);
      return result;

    } catch (error) {
      this.emit('batch_error', batchId, error as Error);
      throw error;
    }
  }

  private async processBatchNode(
    node: NodeForAnnotation, 
    operation: BatchOperation, 
    batchId: string
  ): Promise<BatchResult['results'][0]> {
    const startTime = Date.now();
    let retries = 0;
    const maxRetries = operation.options?.maxRetries || this.errorCorrection.maxRetries;

    while (retries <= maxRetries) {
      try {
        let result: any;

        switch (operation.operation) {
          case "generate_meta":
            result = await this.generateMeta(node);
            await this.saveMeta(node.id, result);
            break;
            
          case "generate_forms":
            result = await this.generateFormSpec(node);
            await this.saveFormSpec(node.id, result);
            break;
            
          case "enhance_schema":
            result = await this.enhanceSchema(node);
            break;
            
          case "classify_pii":
            const piiResults = await this.classifyPii([node]);
            result = piiResults[0];
            break;

          case "generate_rule":
            result = await this.generateRule(node);
            await this.saveRule(node.id, result);
            break;

          case "full_annotation":
            const [meta, rule, form] = await Promise.all([
              this.generateMeta(node),
              this.generateRule(node),
              this.generateFormSpec(node)
            ]);
            result = { meta, rule, form };
            await this.saveMeta(node.id, { ...meta, rule } as unknown as GeneratedMeta);

            await this.saveFormSpec(node.id, form);
            break;

          case "validate_nodes":
            result = await this.validateNode(node);
            break;
        }

        return {
          id: node.id,
          success: true,
          result,
          retries,
          duration: Date.now() - startTime
        };

      } catch (error) {
        retries++;
        if (retries > maxRetries) {
          return {
            id: node.id,
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            retries,
            duration: Date.now() - startTime
          };
        }
        await this.delay(this.errorCorrection.retryDelay * retries);
      }
    }

    return {
      id: node.id,
      success: false,
      error: 'Max retries exceeded',
      retries,
      duration: Date.now() - startTime
    };
  }

  // ============ UTILITY METHODS ============

private selectModelForOperation(operation: string): ModelConfig {
  const hasCapability = (m: ModelConfig) =>
    m.capabilities.includes(operation) || m.capabilities.includes("complex");

  const capable = this.availableModels.filter(hasCapability);

  if (capable.length === 0) {
    const fallback = this.availableModels.find(m => m.name === "fallback");
    if (!fallback) {
      throw new Error("[aiAnnotator] Kein geeignetes Modell verfügbar.");
    }
    return fallback;
  }

  const byName = (name: string) => capable.find(m => m.name === name);

  // 1. Versuch: qwen3:8b (falls Sie das später installieren)
  const qwen8b = byName("qwen3:8b");
  if (qwen8b) return qwen8b;

  // 2. Versuch: qwen3:4b (ist bei Ihnen vorhanden)
  const qwen4b = byName("qwen3:4b");
  if (qwen4b) return qwen4b;

  // 3. Sonstige Ollama-Modelle (z.B. qwen2.5:7b, llama3.1:8b …)
  const anyOllama = capable.find(m => m.provider === "ollama");
  if (anyOllama) return anyOllama;

  // 4. Erst wenn gar kein Ollama-Modell passt: andere Provider (OpenAI/Anthropic)
  const anyCloud = capable.find(
    m => (m.provider === "openai" || m.provider === "anthropic") && m.available
  );
  if (anyCloud) return anyCloud;

  // 5. Letzter Rückfall: lokales Fallback-Modell
  const fallback = this.availableModels.find(m => m.name === "fallback");
  if (fallback) return fallback;

  throw new Error("[aiAnnotator] Kein geeignetes Modell (inkl. Fallback) gefunden.");
}




  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private async correctMetaGeneration(
    node: NodeForAnnotation,
    invalidMeta: GeneratedMeta,
    errors: string[],
    retryCount: number
  ): Promise<GeneratedMeta> {
    const correctionPrompt = this.buildCorrectionPrompt(node, invalidMeta, errors);

    try {
      const correctedRaw = await this.callAI(correctionPrompt, "correction");
      const correctedMeta = this.parseMetaJson(correctedRaw, node);

      return {
        ...correctedMeta,
        quality: {
          confidence: correctedMeta.quality?.confidence ?? 0.5,
          evidence: [...(correctedMeta.quality?.evidence || []), `Corrected: ${errors.join(", ")}`],
          generatedBy: "hybrid",
          modelUsed: this.currentModel
        }
      };
    } catch (error) {
      console.warn(`Meta correction failed for ${node.id}, using validated fallback`);
      return this.generateValidatedFallbackMeta(node, errors);
    }
  }

  private calculateBatchSummary(result: BatchResult): BatchResult['summary'] {
    const confidences = result.results
      .filter(r => r.success && r.result?.quality?.confidence)
      .map(r => r.result.quality.confidence);

    const businessAreas: Record<string, number> = {};
    const piiDistribution: Record<string, number> = {};

    result.results.forEach(r => {
      if (r.success && r.result) {
        const area = r.result.businessArea || 'Unknown';
        businessAreas[area] = (businessAreas[area] || 0) + 1;

        const piiClass = r.result.piiClass || 'none';
        piiDistribution[piiClass] = (piiDistribution[piiClass] || 0) + 1;
      }
    });

    return {
      averageConfidence: confidences.length > 0 
        ? confidences.reduce((a, b) => a + b, 0) / confidences.length 
        : 0,
      businessAreas,
      piiDistribution,
      qualityScore: result.total > 0 ? result.successful / result.total : 0
    };
  }

  // ============ FALLBACK GENERATION ============

  private generateEnhancedFallbackMeta(node: NodeForAnnotation): GeneratedMeta {
    const technical = this.analyzeTechnicalComplexity(node);
    const piiClass = this.guessPiiClass(node);
    
    return {
      description: `Automatisch generierte Beschreibung für: ${node.title}`,
      tags: [node.kind, ...node.title.split(" ").slice(0, 5), ...node.path.slice(-2)],
      businessArea: this.guessBusinessArea(node),
      piiClass: piiClass,
      requires: this.extractDependencies(node),
      quality: { 
        confidence: 0.3, 
        evidence: ["Fallback-Generierung"],
        generatedBy: "fallback",
        modelUsed: "fallback"
      },
      technical,
      compliance: {
        gdprRelevant: piiClass === "high" || piiClass === "medium",
        retentionPeriod: piiClass === "high" ? 3650 : 730,
        auditRequired: piiClass === "high"
      }
    };
  }

  private generateValidatedFallbackMeta(node: NodeForAnnotation, errors: string[]): GeneratedMeta {
  const fallback = this.generateEnhancedFallbackMeta(node);

  return {
    ...fallback,
    quality: {
      confidence: fallback.quality?.confidence ?? 0.3, // ✅ Immer definiert
      generatedBy: "fallback",                         // ✅ Immer vorhanden
      modelUsed: fallback.quality?.modelUsed ?? "fallback",
      evidence: [
        ...(fallback.quality?.evidence || []),
        `Validated fallback due to: ${errors.join(", ")}`
      ]
    }
  };
}


  private generateFallbackRule(node: NodeForAnnotation): DashboardRule {
    const title = node.title.toLowerCase();
    
    if (node.path.length === 1 && title.includes('dashboard')) {
      return {
        type: "dashboard-root",
        widget: "tabs",
        layout: { colSpan: 12, rowSpan: 1, priority: 1 }
      };
    }
    
    if (title.includes('kpi') || title.includes('umsatz') || title.includes('kennzahl')) {
      return {
        type: "metric",
        widget: "number",
        refreshInterval: 60,
        layout: { colSpan: 2, rowSpan: 1, priority: 2 }
      };
    }
    
    if (title.includes('bericht') || title.includes('report')) {
      return {
        type: "report",
        widget: "panel",
        layout: { colSpan: 6, rowSpan: 2, priority: 3 }
      };
    }
    
    return {
      type: "section",
      widget: "panel",
      layout: { colSpan: 3, rowSpan: 1, priority: 4 }
    };
  }

  private generateFallbackForm(node: NodeForAnnotation): FormSpec {
    return {
      title: node.title,
      fields: [{ name: "name", type: "text", label: "Name", required: true }],
      layout: "vertical",
      actions: ["speichern", "abbrechen"]
    };
  }

  private generateLocalFallback(operation: string): string {
    const fallbacks: Record<string, string> = {
      meta: JSON.stringify(this.generateEnhancedFallbackMeta({
        id: 'fallback',
        title: 'Fallback Generation',
        kind: 'system',
        path: []
      })),
      rule: JSON.stringify(this.generateFallbackRule({
        id: 'fallback',
        title: 'Fallback Rule',
        kind: 'system',
        path: []
      })),
      form: JSON.stringify(this.generateFallbackForm({
        id: 'fallback', 
        title: 'Fallback Form',
        kind: 'system',
        path: []
      }))
    };

    return fallbacks[operation] || '{}';
  }

  // ============ HELPER METHODS ============

  private analyzeTechnicalComplexity(node: NodeForAnnotation): GeneratedMeta['technical'] {
    const title = node.title.toLowerCase();
    let complexity: "low" | "medium" | "high" = "low";
    let dataVolume: "small" | "medium" | "large" = "small";
    let performanceImpact: "low" | "medium" | "high" = "low";

    if (title.includes('report') || title.includes('analyse') || title.includes('statistik')) {
      dataVolume = "large";
      performanceImpact = "medium";
    }

    if (title.includes('transaktion') || title.includes('buchung') || title.includes('rechnung')) {
      complexity = "medium";
      performanceImpact = "medium";
    }

    if (title.includes('integration') || title.includes('synchronisation') || title.includes('api')) {
      complexity = "high";
      performanceImpact = "high";
    }

    return {
      complexity,
      dataVolume,
      integrationPoints: this.extractIntegrationPoints(node),
      performanceImpact
    };
  }

  private extractIntegrationPoints(node: NodeForAnnotation): string[] {
    const integrations: string[] = [];
    const title = node.title.toLowerCase();
    const path = node.path.join(' ').toLowerCase();

    if (title.includes('kunde') || path.includes('kunde')) integrations.push('CRM');
    if (title.includes('lieferant') || path.includes('lieferant')) integrations.push('Lieferantenmanagement');
    if (title.includes('lager') || path.includes('lager')) integrations.push('Warenwirtschaft');
    if (title.includes('personal') || path.includes('personal')) integrations.push('HR-System');
    if (title.includes('finanz') || path.includes('finanz')) integrations.push('Finanzbuchhaltung');

    return integrations.slice(0, 3);
  }

  private extractDependencies(node: NodeForAnnotation): string[] {
    const dependencies: string[] = [];
    
    if (node.path.length > 1) {
      dependencies.push(node.path[node.path.length - 2]);
    }

    if (node.meta_json?.requires) {
      dependencies.push(...node.meta_json.requires);
    }

    return [...new Set(dependencies)].slice(0, 5);
  }

  private guessBusinessArea(node: NodeForAnnotation): string {
    const title = node.title.toLowerCase();
    const areaMap: Record<string, string> = {
      'umsatz': 'Finanzen', 'kosten': 'Finanzen', 'finanz': 'Finanzen', 'rechnung': 'Finanzen',
      'kunde': 'Vertrieb', 'vertrieb': 'Vertrieb', 'auftrag': 'Vertrieb', 'angebot': 'Vertrieb',
      'einkauf': 'Einkauf', 'lieferant': 'Einkauf', 'bestellung': 'Einkauf',
      'personal': 'HR', 'mitarbeiter': 'HR', 'gehalt': 'HR', 'lohn': 'HR',
      'produkt': 'Produktion', 'fertigung': 'Produktion', 'lager': 'Produktion', 'material': 'Produktion',
      'system': 'IT', 'benutzer': 'IT', 'rolle': 'IT', 'berechtigung': 'IT'
    };

    for (const [keyword, area] of Object.entries(areaMap)) {
      if (title.includes(keyword)) return area;
    }

    return 'Allgemein';
  }

  private guessPiiClass(node: NodeForAnnotation): "none" | "low" | "medium" | "high" {
    const title = node.title.toLowerCase();
    if (title.includes('personal') || title.includes('gehalt') || title.includes('lohn')) return 'high';
    if (title.includes('kunde') || title.includes('adresse') || title.includes('email')) return 'medium';
    if (title.includes('benutzer') || title.includes('rolle') || title.includes('abteilung')) return 'low';
    return 'none';
  }

  // ============ PUBLIC API ============

  async validateNode(node: NodeForAnnotation): Promise<{
    valid: boolean;
    errors: string[];
    warnings: string[];
    suggestions: string[];
  }> {
    const errors: string[] = [];
    const warnings: string[] = [];
    const suggestions: string[] = [];

    if (!node.meta_json) {
      errors.push("Keine Metadaten vorhanden");
    } else {
      const metaValidation = this.validateMeta(node.meta_json);
      if (!metaValidation.valid) {
        errors.push(...metaValidation.errors);
      }
    }

    if (!node.schema_json) {
      warnings.push("Kein Schema vorhanden");
    }

    if (node.title.length < 3) {
      warnings.push("Titel sehr kurz");
    }

    if (node.path.length === 0) {
      warnings.push("Kein Pfad definiert");
    }

    if (this.provider !== 'none') {
      try {
        const aiValidation = await this.aiValidateNode(node);
        suggestions.push(...aiValidation.suggestions);
      } catch (error) {
        console.warn('AI validation failed:', error);
      }
    }

    return { valid: errors.length === 0, errors, warnings, suggestions };
  }

 private async aiValidateNode(node: NodeForAnnotation): Promise<{ suggestions: string[] }> {
  const prompt = `
# VALIDIERUNG ERP-FUNKTIONSKNOTEN

## KNOTEN:
${JSON.stringify({
    title: node.title,
    kind: node.kind,
    path: node.path,
    meta: node.meta_json
  }, null, 2)}

## AUFGABE:
Analysiere den Funktionsknoten und gib Verbesserungsvorschläge.

Antworte mit JSON: {"suggestions": ["string"]}
  `;

  try {
    const response = await this.callAI(prompt, "validation");

    let parsed: any;
    try {
      parsed = JSON.parse(response);
    } catch {
      // Versuch JSON aus Text zu extrahieren
      const match = response.match(/\{[\s\S]*\}/);
      if (match) {
        try {
          parsed = JSON.parse(match[0]);
        } catch {
          parsed = null;
        }
      }
    }

    if (!parsed || !Array.isArray(parsed.suggestions)) {
      return { suggestions: [] };
    }

    return parsed;

  } catch (err) {
    console.warn("AI validation failed:", err);
    return { suggestions: [] };
  }
}


  async getStatus() {
    const health = await this.getSystemHealth();
    
    return {
      provider: this.provider,
      available: this.provider !== 'none',
      model: this.currentModel,
      capabilities: this.availableModels.flatMap(m => m.capabilities),
      health,
      errorCorrection: this.errorCorrection
    };
  }

  
  async validateConfig() {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (this.provider === 'none') {
      warnings.push('Kein AI-Provider konfiguriert - nur Fallback verfügbar');
    }

    const availableModels = this.availableModels.filter(m => m.available);
    if (availableModels.length === 0) {
      errors.push('Keine AI-Modelle verfügbar');
    }

    if (this.provider === 'ollama') {
      try {
        const baseUrl = process.env.OLLAMA_BASE_URL || "http://localhost:11434";
        const response = await fetch(`${baseUrl}/api/tags`);
        if (!response.ok) {
          errors.push('Ollama nicht erreichbar');
        }
      } catch {
        errors.push('Ollama nicht erreichbar');
      }
    }

    try {
      await this.databaseTool.getTotalNodeCount();
    } catch (error) {
      errors.push('Datenbank nicht erreichbar');
    }

    return { valid: errors.length === 0, errors, warnings };
  }
  private async getNodeMeta(id: string): Promise<any> {
    try {
      const nodes = await this.listCandidates({ search: id, limit: 1 });
      return nodes[0]?.meta_json || {};
    } catch {
      return {};
    }
  }

  private async getSystemHealth(): Promise<any> {
    // Basic system diagnostics for status endpoints: node version, uptime, memory, CPU and
    // availability of database and configured AI provider reachability (best-effort).
    const mem = process.memoryUsage();
    let dbOk = true;
    try {
      await this.databaseTool.getTotalNodeCount();
    } catch {
      dbOk = false;
    }

    let providerReachable: boolean | null = null;
    try {
      if (this.provider === "ollama") {
        const baseUrl = process.env.OLLAMA_BASE_URL || "http://localhost:11434";
        const resp = await fetch(`${baseUrl}/api/tags`);
        providerReachable = resp.ok;
      } else if (this.provider === "openai") {
        providerReachable = !!process.env.OPENAI_API_KEY;
      } else if (this.provider === "anthropic") {
        providerReachable = !!process.env.ANTHROPIC_API_KEY;
      } else if (this.provider === "local") {
        providerReachable = !!process.env.LOCAL_MODEL_PATH;
      } else {
        providerReachable = false;
      }
    } catch {
      providerReachable = false;
    }

    return {
      nodeVersion: process.version,
      uptime: process.uptime(),
      memory: {
        rss: mem.rss,
        heapTotal: mem.heapTotal,
        heapUsed: mem.heapUsed
      },
      cpuCount: os.cpus().length,
      loadAverage: os.loadavg(),
      database: {
        ok: dbOk
      },
      aiProvider: {
        name: this.provider,
        available: this.provider !== "none",
        reachable: providerReachable
      }
    };
  }
}

export default new AiAnnotatorService();